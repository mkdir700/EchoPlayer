---
description: 
globs: 
alwaysApply: false
---
# 组件架构重构最佳实践

## 概述

本文档总结了将复杂的 props 传递模式重构为组件内部直接使用 hooks 的最佳实践。这种重构模式有助于提升代码的可维护性和组件的独立性。

## 重构原则

### 1. 组件自治原则
- **原则**: 组件应该直接管理自己需要的状态，而不是通过 props 接收所有依赖
- **实现**: 在组件内部直接使用相关的 hooks，而不是从父组件传递复杂的对象
- **好处**: 减少组件间的耦合，提升组件的可复用性

### 2. 最小化 Props 接口
- **原则**: 只传递组件真正需要的最小化参数
- **实现**: 将复杂的状态管理逻辑移到组件内部，只保留必要的回调函数
- **好处**: 简化组件接口，降低使用复杂度

### 3. 状态就近管理
- **原则**: 状态应该在最接近使用它的地方进行管理
- **实现**: 将特定功能的状态管理移到对应的组件中
- **好处**: 提升代码的局部性，便于理解和维护

## 重构步骤

### 步骤1: 识别可移动的状态
```typescript
// 重构前 - 在父组件中管理所有状态
const App = () => {
  const videoPlayer = useVideoPlayer()
  const subtitles = useSubtitles()
  const sidebarResize = useSidebarResize(containerRef)
  
  return <PlayPage 
    videoPlayer={videoPlayer}
    subtitles={subtitles}
    sidebarResize={sidebarResize}
  />
}

// 重构后 - 子组件自己管理状态
const PlayPage = ({ onBack }) => {
  const videoPlayer = useVideoPlayer()
  const subtitles = useSubtitles()
  const sidebarResize = useSidebarResize(containerRef)
  
  // 组件逻辑...
}
```

### 步骤2: 移除复杂的 Props 类型定义
```typescript
// 重构前 - 复杂的 Props 接口
interface PlayPageProps {
  videoPlayer: {
    isPlaying: boolean
    volume: number
    // ... 20+ 个属性
  }
  subtitles: {
    subtitles: SubtitleItem[]
    // ... 10+ 个属性
  }
  // ... 更多复杂对象
}

// 重构后 - 简化的 Props 接口
interface PlayPageProps {
  onBack: () => void
}
```

### 步骤3: 清理父组件
```typescript
// 重构前 - 父组件管理大量状态
const App = () => {
  // 10+ 个 hooks
  const videoPlayer = useVideoPlayer()
  const subtitles = useSubtitles()
  // ...
  
  // 复杂的状态同步逻辑
  // 大量的 useEffect
  // 复杂的 memoization
}

// 重构后 - 父组件专注于页面导航
const App = () => {
  const [currentPage, setCurrentPage] = useState('home')
  
  // 简化的状态管理
  // 专注于应用级别的状态
}
```

## 架构优势

### 1. 降低复杂度
- 减少了组件间的数据传递
- 简化了 props 接口
- 降低了组件使用的心智负担

### 2. 提升可维护性
- 相关逻辑集中在一个组件中
- 减少了跨组件的状态同步问题
- 便于单独测试和调试

### 3. 增强可复用性
- 组件不再依赖特定的 props 结构
- 可以在不同的上下文中独立使用
- 减少了对父组件实现的依赖

## 注意事项

### 1. 状态共享问题
- **问题**: 某些状态可能需要在多个组件间共享
- **解决方案**: 使用 Context API 或状态管理库
- **示例**: 全局的用户设置、主题配置等

### 2. 性能考虑
- **问题**: 组件内部的 hooks 可能导致不必要的重新渲染
- **解决方案**: 合理使用 useMemo、useCallback 进行优化
- **示例**: 缓存计算结果、稳定化回调函数

### 3. 类型安全
- **问题**: 移除 props 类型定义后可能失去类型检查
- **解决方案**: 确保 hooks 返回值有正确的类型定义
- **示例**: 为自定义 hooks 提供完整的 TypeScript 类型

## 最佳实践总结

1. **渐进式重构**: 不要一次性重构所有组件，逐步进行
2. **保持接口稳定**: 重构过程中尽量保持对外接口的稳定性
3. **充分测试**: 重构后进行充分的功能测试
4. **文档更新**: 及时更新相关的文档和注释
5. **团队沟通**: 确保团队成员理解新的架构模式

## 适用场景

### 适合重构的情况
- Props 接口过于复杂（超过 5-10 个属性）
- 组件间存在大量的状态传递
- 父组件承担了过多的状态管理责任
- 组件复用困难

### 不适合重构的情况
- 状态确实需要在多个组件间共享
- 组件是纯展示组件，不应该包含业务逻辑
- 重构成本过高，收益不明显

通过遵循这些原则和实践，可以构建出更加清晰、可维护的组件架构。
