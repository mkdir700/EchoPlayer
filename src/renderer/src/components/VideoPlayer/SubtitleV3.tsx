import React, { useState, useCallback, useMemo, useRef, useEffect, memo } from 'react'
import { WordCard } from '@renderer/components/WordCard/WordCard'
import { usePlayingVideoContext } from '@renderer/hooks/usePlayingVideoContext'
import {
  useSubtitleState,
  createDefaultSubtitleDisplay,
  type SubtitleMarginsState,
  type BackgroundType
} from '@renderer/hooks/useSubtitleState'
import { useSubtitleDragAndResize } from '@renderer/hooks/useSubtitleDragAndResize'
import { useSubtitleStyles } from '@renderer/hooks/useSubtitleStyles'
import { SubtitleControls } from './SubtitleControls'
import { SubtitleContent } from './SubtitleContent'
import { MaskFrame } from './MaskFrame'
import RendererLogger from '@renderer/utils/logger'
import styles from './Subtitle.module.css'

interface SubtitleV3Props {
  onWordHover: (isHovering: boolean) => void
  onPauseOnHover: () => void
}

// ÊãÜÂàÜÂ≠êÁªÑ‰ª∂ÔºöÈÅÆÁΩ©Ë¶ÜÁõñÂ±Ç
const MaskOverlay = memo(
  ({ maskFrame }: { maskFrame: SubtitleMarginsState['maskFrame'] }): React.JSX.Element => {
    const style = useMemo(
      (): React.CSSProperties => ({
        position: 'absolute',
        left: '0%',
        top: '0%',
        width: '100%',
        height: '100%',
        zIndex: 5,
        pointerEvents: 'none',
        transition: 'all 0.3s ease-in-out'
      }),
      [maskFrame.width, maskFrame.height, maskFrame.left, maskFrame.top]
    )

    return <div className={styles.maskOverlay} style={style} />
  }
)
MaskOverlay.displayName = 'MaskOverlay'

// ÊãÜÂàÜÂ≠êÁªÑ‰ª∂ÔºöÊéßÂà∂ÊåâÈíÆ
const SubtitleControlsWrapper = memo(
  ({
    visible,
    currentLayout,
    subtitleState,
    buttonSize,
    iconSize,
    onToggleMaskMode,
    onToggleBackgroundType,
    onReset,
    onExpandHorizontally,
    onMouseEnter,
    onMouseLeave
  }: {
    visible: boolean
    currentLayout: { left: number; top: number; width: number; height: number }
    subtitleState: { isMaskMode: boolean; backgroundType: BackgroundType }
    buttonSize: number
    iconSize: number
    onToggleMaskMode: () => void
    onToggleBackgroundType: () => void
    onReset: () => void
    onExpandHorizontally: () => void
    onMouseEnter: () => void
    onMouseLeave: () => void
  }): React.JSX.Element | null => {
    const controlsStyle = useMemo(
      (): React.CSSProperties => ({
        position: 'absolute',
        left: `${Math.min(95, currentLayout.left + currentLayout.width)}%`,
        top: `${Math.max(5, currentLayout.top - 2)}%`,
        transform: 'translate(-100%, -100%)',
        zIndex: 150
      }),
      [currentLayout.left, currentLayout.top, currentLayout.width]
    )

    if (!visible) return null

    return (
      <div
        className={styles.subtitleControlsExternal}
        style={controlsStyle}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
      >
        <SubtitleControls
          isMaskMode={subtitleState.isMaskMode}
          backgroundType={subtitleState.backgroundType}
          buttonSize={buttonSize}
          iconSize={iconSize}
          onToggleMaskMode={onToggleMaskMode}
          onToggleBackgroundType={onToggleBackgroundType}
          onReset={onReset}
          onExpandHorizontally={onExpandHorizontally}
        />
      </div>
    )
  }
)
SubtitleControlsWrapper.displayName = 'SubtitleControlsWrapper'

// ÊãÜÂàÜÂ≠êÁªÑ‰ª∂ÔºöË∞ÉÊï¥Â§ßÂ∞èÊéßÂà∂ÁÇπ
const ResizeHandle = memo(
  ({
    visible,
    buttonSize,
    onMouseDown
  }: {
    visible: boolean
    buttonSize: number
    onMouseDown: (e: React.MouseEvent) => void
  }): React.JSX.Element | null => {
    const handleStyle = useMemo(
      (): React.CSSProperties => ({
        position: 'absolute',
        bottom: 0,
        right: 0,
        width: `${Math.max(12, Math.min(24, buttonSize * 0.5))}px`,
        height: `${Math.max(12, Math.min(24, buttonSize * 0.5))}px`,
        cursor: 'se-resize'
      }),
      [buttonSize]
    )

    if (!visible) return null

    return (
      <div
        className={`${styles.resizeHandle} ${styles.resizeHandleSE}`}
        onMouseDown={onMouseDown}
        style={handleStyle}
      />
    )
  }
)
ResizeHandle.displayName = 'ResizeHandle'

function SubtitleV3({ onWordHover, onPauseOnHover }: SubtitleV3Props): React.JSX.Element {
  RendererLogger.componentRender({
    component: 'SubtitleV3',
    props: { onWordHover, onPauseOnHover }
  })

  // Ëé∑ÂèñËßÜÈ¢ë‰∏ä‰∏ãÊñá
  const { displayAspectRatio } = usePlayingVideoContext()

  // Êú¨Âú∞Áä∂ÊÄÅ
  const [selectedWord, setSelectedWord] = useState<{
    word: string
    element: HTMLElement
  } | null>(null)
  const [isHovering, setIsHovering] = useState(false)
  const [isControlsHovering, setIsControlsHovering] = useState(false)
  const [isMaskFrameActive, setIsMaskFrameActive] = useState(false)
  const [isMaskFrameHovering, setIsMaskFrameHovering] = useState(false)

  // ÂºïÁî®
  const containerRef = useRef<HTMLDivElement>(null)
  const hideTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const maskFrameCheckTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const parentDimensionsRef = useRef({ width: 0, height: 0 })
  const renderCount = useRef(0)

  // Á®≥ÂÆöÁöÑÂõûË∞ÉÂáΩÊï∞ - ‰ΩøÁî® useRef Â≠òÂÇ®ÊúÄÊñ∞ÂÄºÔºå‰øùÊåÅÂáΩÊï∞ÂºïÁî®Á®≥ÂÆö
  const callbacksRef = useRef({
    onWordHover,
    onPauseOnHover
  })

  // Êõ¥Êñ∞ÂõûË∞ÉÂºïÁî®
  useEffect(() => {
    callbacksRef.current = {
      onWordHover,
      onPauseOnHover
    }
  }, [onWordHover, onPauseOnHover])

  // Ëé∑ÂèñÁà∂ÂÆπÂô®Â∞∫ÂØ∏ - Âè™ËÆ°ÁÆó‰∏ÄÊ¨°
  const parentDimensions = useMemo(() => {
    const parent = containerRef.current?.parentElement
    const dimensions = {
      width: parent?.clientWidth || 0,
      height: parent?.clientHeight || 0
    }
    parentDimensionsRef.current = dimensions
    return dimensions
  }, [])

  // Ëé∑ÂèñÁà∂ÂÆπÂô®ËæπÁïåÁöÑÁ®≥ÂÆöÂáΩÊï∞
  const getParentBounds = useCallback(() => {
    const parent = containerRef.current?.parentElement
    if (parent) {
      const dimensions = {
        width: parent.clientWidth,
        height: parent.clientHeight
      }
      parentDimensionsRef.current = dimensions
      return dimensions
    }
    return parentDimensionsRef.current
  }, [])

  // ‰ΩøÁî®Áä∂ÊÄÅÁÆ°ÁêÜ hook
  const { subtitleState, updateSubtitleState, toggleBackgroundType, toggleMaskMode } =
    useSubtitleState(parentDimensions.width, parentDimensions.height, displayAspectRatio)

  // ËÆ°ÁÆóÂΩìÂâçÂ∏ÉÂ±Ä - Âè™‰æùËµñÂøÖË¶ÅÁöÑÁä∂ÊÄÅ
  const currentLayout = useMemo(() => {
    const { left, top, right, bottom } = subtitleState.margins
    return {
      left,
      top,
      width: 100 - left - right,
      height: 100 - top - bottom
    }
  }, [
    subtitleState.margins.left,
    subtitleState.margins.top,
    subtitleState.margins.right,
    subtitleState.margins.bottom
  ])

  // ‰ΩøÁî®ÊãñÊãΩÂíåË∞ÉÊï¥Â§ßÂ∞è hook
  const dragAndResizeProps = useSubtitleDragAndResize(
    subtitleState,
    updateSubtitleState,
    getParentBounds,
    currentLayout
  )

  // ‰ΩøÁî®Ê†∑Âºè hook
  const {
    dynamicTextStyle,
    dynamicEnglishTextStyle,
    dynamicChineseTextStyle,
    buttonSize,
    iconSize
  } = useSubtitleStyles(currentLayout)

  // Á®≥ÂÆöÁöÑ‰∫ã‰ª∂Â§ÑÁêÜÂáΩÊï∞
  const stableHandlers = useMemo(
    () => ({
      // Â§ÑÁêÜÂçïËØçhover‰∫ã‰ª∂
      handleWordHover: (isHovering: boolean): void => {
        callbacksRef.current.onWordHover(isHovering)
        if (isHovering) {
          console.log('Ëß¶ÂèëÊöÇÂÅúËßÜÈ¢ë')
          callbacksRef.current.onPauseOnHover()
        }
      },

      // Â§ÑÁêÜÂçïËØçÁÇπÂáª‰∫ã‰ª∂
      handleWordClick: (word: string, event: React.MouseEvent): void => {
        event.stopPropagation()
        event.preventDefault()

        const trimmedWord = word.trim()
        if (trimmedWord === '') {
          return
        }

        const wordElement = event.target as HTMLElement
        setSelectedWord({
          word: trimmedWord,
          element: wordElement
        })
      },

      // Ê£ÄÊü•ÊòØÂê¶ÊòØÂçïËØçÂÖÉÁ¥†
      isWordElement: (element: HTMLElement): boolean => {
        if (
          element.classList.contains('subtitleWord') ||
          element.classList.contains('clickableWord')
        ) {
          return true
        }

        let parent = element.parentElement
        let depth = 0
        while (parent && depth < 3) {
          if (
            parent.classList.contains('subtitleWord') ||
            parent.classList.contains('clickableWord')
          ) {
            return true
          }
          parent = parent.parentElement
          depth++
        }
        return false
      },

      // ÂÖ≥Èó≠ÂçïËØçÂç°Áâá
      handleCloseWordCard: (): void => {
        setSelectedWord(null)
      },

      // Êõ¥Êñ∞ÈÅÆÁΩ©Ê°Ü
      updateMaskFrame: (maskFrame: SubtitleMarginsState['maskFrame']): void => {
        updateSubtitleState({
          ...subtitleState,
          maskFrame
        })
      },

      // ÈáçÁΩÆÂ≠óÂπïÁä∂ÊÄÅ
      resetSubtitleState: (): void => {
        const cleanState = createDefaultSubtitleDisplay()
        updateSubtitleState(cleanState)
        if (process.env.NODE_ENV === 'development') {
          console.log('üîÑ ÈáçÁΩÆÂ≠óÂπïÁä∂ÊÄÅÂà∞:', cleanState)
        }
      },

      // ‰∏ÄÈîÆÈì∫Êª°Â∑¶Âè≥
      expandHorizontally: (): void => {
        const parent = containerRef.current?.parentElement
        if (!parent) {
          console.warn('‚ö†Ô∏è Êó†Ê≥ïËé∑ÂèñÁà∂ÂÆπÂô®Ôºå‰ΩøÁî®ÈªòËÆ§ËæπË∑ù')
          updateSubtitleState({
            ...subtitleState,
            margins: {
              ...subtitleState.margins,
              left: 5,
              right: 5
            }
          })
          return
        }

        // ËÆ°ÁÆóËßÜÈ¢ëÂú®ÂÆπÂô®‰∏≠ÁöÑÂÆûÈôÖÊòæÁ§∫Âå∫Âüü
        const containerWidth = parent.clientWidth
        const containerHeight = parent.clientHeight
        const containerAspectRatio = containerWidth / containerHeight

        let videoDisplayWidth: number, videoLeft: number

        if (displayAspectRatio > containerAspectRatio) {
          // ËßÜÈ¢ëÊØîÂÆπÂô®Êõ¥ÂÆΩÔºå‰ª•ÂÆπÂô®ÂÆΩÂ∫¶‰∏∫ÂáÜËøõË°åÁº©Êîæ
          videoDisplayWidth = containerWidth
          videoLeft = 0
        } else {
          // ËßÜÈ¢ëÊØîÂÆπÂô®Êõ¥È´òÔºàÊàñÁõ∏Á≠âÔºâÔºå‰ª•ÂÆπÂô®È´òÂ∫¶‰∏∫ÂáÜËøõË°åÁº©Êîæ
          videoDisplayWidth = containerHeight * displayAspectRatio
          videoLeft = (containerWidth - videoDisplayWidth) / 2
        }

        // ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
        const videoLeftPercent = (videoLeft / containerWidth) * 100
        const videoRightPercent =
          ((containerWidth - (videoLeft + videoDisplayWidth)) / containerWidth) * 100

        // ËÆæÁΩÆÂ≠óÂπïÂå∫ÂüüÁöÑÂ∑¶Âè≥ËæπË∑ù‰∏∫ËßÜÈ¢ëÊòæÁ§∫Âå∫ÂüüÁöÑËæπÁïåÔºåÂÜçÂä†‰∏äÈÄÇÂΩìÁöÑÂÜÖËæπË∑ù
        const horizontalPadding = 2 // 2% ÁöÑÂÜÖËæπË∑ùÔºåÁ°Æ‰øùÂ≠óÂπï‰∏ç‰ºöÁ¥ßË¥¥ËßÜÈ¢ëËæπÁºò
        const leftMargin = Math.max(0, videoLeftPercent + horizontalPadding)
        const rightMargin = Math.max(0, videoRightPercent + horizontalPadding)

        updateSubtitleState({
          ...subtitleState,
          margins: {
            ...subtitleState.margins,
            left: leftMargin,
            right: rightMargin
          }
        })

        if (process.env.NODE_ENV === 'development') {
          console.log('‚Üî ‰∏ÄÈîÆÈì∫Êª°Â∑¶Âè≥ - Âü∫‰∫éËßÜÈ¢ëÊòæÁ§∫Âå∫Âüü:', {
            displayAspectRatio,
            containerAspectRatio,
            videoDisplayArea: {
              left: videoLeftPercent,
              width: (videoDisplayWidth / containerWidth) * 100
            },
            calculatedMargins: {
              left: leftMargin,
              right: rightMargin
            }
          })
        }
      },

      // ÂÆπÂô®Èº†Ê†áÊåâ‰∏ã‰∫ã‰ª∂Â§ÑÁêÜ
      handleContainerMouseDown: (e: React.MouseEvent): void => {
        const target = e.target as HTMLElement
        if (stableHandlers.isWordElement(target)) {
          e.stopPropagation()
          return
        }
        dragAndResizeProps.handleMouseDown(e, containerRef)
      },

      // ÊÇ¨ÂÅúÊéßÂà∂
      handleMouseEnter: (): void => {
        if (hideTimeoutRef.current) {
          clearTimeout(hideTimeoutRef.current)
          hideTimeoutRef.current = null
        }
        setIsHovering(true)
        // Âú®ÈÅÆÁΩ©Ê®°Âºè‰∏ãÔºåËøõÂÖ•Â≠óÂπïÂå∫ÂüüÊó∂ÊøÄÊ¥ªÈÅÆÁΩ©ËæπÊ°Ü
        if (subtitleState.isMaskMode) {
          setIsMaskFrameActive(true)
        }
      },

      handleMouseLeave: (): void => {
        hideTimeoutRef.current = setTimeout(() => {
          if (!isControlsHovering) {
            setIsHovering(false)
          }
          hideTimeoutRef.current = null
        }, 100)

        // ÂçïÁã¨ÁöÑÂª∂Êó∂Ê£ÄÊü•ÈÅÆÁΩ©ËæπÊ°ÜÁä∂ÊÄÅ
        if (maskFrameCheckTimeoutRef.current) {
          clearTimeout(maskFrameCheckTimeoutRef.current)
        }
        maskFrameCheckTimeoutRef.current = setTimeout(() => {
          // ‰ΩøÁî® DOM Êü•ËØ¢Êù•Ëé∑ÂèñÂÆûÊó∂ÁöÑÊÇ¨ÂÅúÁä∂ÊÄÅ
          const subtitleHovering = containerRef.current?.matches(':hover') || false
          const controlsHovering =
            document.querySelector(`.${styles.subtitleControlsExternal}:hover`) !== null
          const maskFrameHovering = document.querySelector(`.${styles.maskFrame}:hover`) !== null

          if (!subtitleHovering && !controlsHovering && !maskFrameHovering) {
            setIsMaskFrameActive(false)
          }
        }, 150)
      },

      // ÊéßÂà∂ÊåâÈíÆÊÇ¨ÂÅú
      handleControlsMouseEnter: (): void => {
        setIsControlsHovering(true)
        // Âú®ÈÅÆÁΩ©Ê®°Âºè‰∏ãÔºåËøõÂÖ•ÊéßÂà∂Âå∫ÂüüÊó∂ÊøÄÊ¥ªÈÅÆÁΩ©ËæπÊ°Ü
        if (subtitleState.isMaskMode) {
          setIsMaskFrameActive(true)
        }
      },

      handleControlsMouseLeave: (): void => {
        setIsControlsHovering(false)

        // Âª∂Êó∂Ê£ÄÊü•ÈÅÆÁΩ©ËæπÊ°ÜÁä∂ÊÄÅ
        if (maskFrameCheckTimeoutRef.current) {
          clearTimeout(maskFrameCheckTimeoutRef.current)
        }
        maskFrameCheckTimeoutRef.current = setTimeout(() => {
          const subtitleHovering = containerRef.current?.matches(':hover') || false
          const controlsHovering =
            document.querySelector(`.${styles.subtitleControlsExternal}:hover`) !== null
          const maskFrameHovering = document.querySelector(`.${styles.maskFrame}:hover`) !== null

          if (!subtitleHovering && !controlsHovering && !maskFrameHovering) {
            setIsMaskFrameActive(false)
          }
        }, 150)
      },

      // ÈÅÆÁΩ©Ê°ÜÊÇ¨ÂÅúÂ§ÑÁêÜ
      handleMaskFrameMouseEnter: (): void => {
        setIsMaskFrameHovering(true)
        setIsMaskFrameActive(true)
      },

      handleMaskFrameMouseLeave: (): void => {
        setIsMaskFrameHovering(false)

        // Âª∂Êó∂Ê£ÄÊü•ÈÅÆÁΩ©ËæπÊ°ÜÁä∂ÊÄÅ
        if (maskFrameCheckTimeoutRef.current) {
          clearTimeout(maskFrameCheckTimeoutRef.current)
        }
        maskFrameCheckTimeoutRef.current = setTimeout(() => {
          const subtitleHovering = containerRef.current?.matches(':hover') || false
          const controlsHovering =
            document.querySelector(`.${styles.subtitleControlsExternal}:hover`) !== null
          const maskFrameHovering = document.querySelector(`.${styles.maskFrame}:hover`) !== null

          if (!subtitleHovering && !controlsHovering && !maskFrameHovering) {
            setIsMaskFrameActive(false)
          }
        }, 150)
      },

      // Ë∞ÉÊï¥Â§ßÂ∞èÊéßÂà∂ÁÇπ
      handleResizeMouseDown: (e: React.MouseEvent): void => {
        dragAndResizeProps.handleResizeMouseDown(e, 'se')
      }
    }),
    [
      subtitleState,
      updateSubtitleState,
      dragAndResizeProps.handleMouseDown,
      dragAndResizeProps.handleResizeMouseDown,
      isControlsHovering,
      isHovering,
      isMaskFrameHovering,
      displayAspectRatio,
      containerRef
    ]
  )

  // ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨Âô®ÁÆ°ÁêÜ
  useEffect(() => {
    const isDraggingOrResizing = dragAndResizeProps.isDragging || dragAndResizeProps.isResizing

    if (isDraggingOrResizing) {
      const handleMouseMove = (e: MouseEvent): void => {
        dragAndResizeProps.handleMouseMove(e, containerRef)
      }
      const handleMouseUp = (): void => {
        dragAndResizeProps.handleMouseUp()
      }

      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)

      return () => {
        document.removeEventListener('mousemove', handleMouseMove)
        document.removeEventListener('mouseup', handleMouseUp)
      }
    }
  }, [
    dragAndResizeProps.isDragging,
    dragAndResizeProps.isResizing,
    dragAndResizeProps.handleMouseMove,
    dragAndResizeProps.handleMouseUp
  ])

  // Ê∏ÖÁêÜÂÆöÊó∂Âô®
  useEffect(() => {
    return () => {
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current)
      }
      if (maskFrameCheckTimeoutRef.current) {
        clearTimeout(maskFrameCheckTimeoutRef.current)
      }
    }
  }, [])

  // ÁõëÂê¨ÈÅÆÁΩ©Ê®°ÂºèÂèòÂåñÔºåÈÄÄÂá∫Êó∂ÈáçÁΩÆÁõ∏ÂÖ≥Áä∂ÊÄÅ
  useEffect(() => {
    if (!subtitleState.isMaskMode) {
      setIsMaskFrameActive(false)
      setIsMaskFrameHovering(false)
    }
  }, [subtitleState.isMaskMode])

  // ËÆ°ÁÆóÂÆûÈôÖËÉåÊôØÁ±ªÂûã
  const actualBackgroundType = useMemo(() => {
    const isDraggingOrResizing = dragAndResizeProps.isDragging || dragAndResizeProps.isResizing
    return isDraggingOrResizing ? 'transparent' : subtitleState.backgroundType
  }, [dragAndResizeProps.isDragging, dragAndResizeProps.isResizing, subtitleState.backgroundType])

  // ÂÆπÂô®Ê†∑Âºè
  const containerStyle = useMemo((): React.CSSProperties => {
    const isDraggingOrResizing = dragAndResizeProps.isDragging || dragAndResizeProps.isResizing
    const cursor = dragAndResizeProps.isDragging
      ? 'grabbing'
      : dragAndResizeProps.isResizing
        ? 'se-resize'
        : 'grab'

    const left = subtitleState.isMaskMode
      ? `${subtitleState.maskFrame.left + (currentLayout.left * subtitleState.maskFrame.width) / 100}%`
      : `${currentLayout.left}%`

    const top = subtitleState.isMaskMode
      ? `${subtitleState.maskFrame.top + (currentLayout.top * subtitleState.maskFrame.height) / 100}%`
      : `${currentLayout.top}%`

    const width = subtitleState.isMaskMode
      ? `${(currentLayout.width * subtitleState.maskFrame.width) / 100}%`
      : `${currentLayout.width}%`

    const height = subtitleState.isMaskMode
      ? `${(currentLayout.height * subtitleState.maskFrame.height) / 100}%`
      : `${currentLayout.height}%`

    return {
      position: 'absolute',
      left,
      top,
      width,
      height,
      cursor,
      zIndex: isDraggingOrResizing ? 100 : 10,
      userSelect: isDraggingOrResizing ? 'none' : 'auto'
    }
  }, [
    subtitleState.isMaskMode,
    subtitleState.maskFrame,
    currentLayout,
    dragAndResizeProps.isDragging,
    dragAndResizeProps.isResizing
  ])

  // ÂºÄÂèëÁéØÂ¢ÉË∞ÉËØï
  if (process.env.NODE_ENV === 'development') {
    renderCount.current += 1
    if (renderCount.current % 10 === 0) {
      console.log(`üîÑ SubtitleV3 Ê∏≤Êüì #${renderCount.current}`)
    }
  }

  return (
    <>
      {/* ÈÅÆÁΩ©Ê®°ÂºèÊïàÊûú */}
      {subtitleState.isMaskMode && (
        <>
          <MaskOverlay maskFrame={subtitleState.maskFrame} />
          <MaskFrame
            maskFrame={subtitleState.maskFrame}
            updateMaskFrame={stableHandlers.updateMaskFrame}
            containerRef={containerRef}
            isMaskFrameActive={isMaskFrameActive}
            onMaskFrameMouseEnter={stableHandlers.handleMaskFrameMouseEnter}
            onMaskFrameMouseLeave={stableHandlers.handleMaskFrameMouseLeave}
          />
        </>
      )}

      {/* ÊéßÂà∂ÊåâÈíÆ */}
      <SubtitleControlsWrapper
        visible={!dragAndResizeProps.isDragging && (isHovering || isControlsHovering)}
        currentLayout={currentLayout}
        subtitleState={subtitleState}
        buttonSize={buttonSize}
        iconSize={iconSize}
        onToggleMaskMode={toggleMaskMode}
        onToggleBackgroundType={toggleBackgroundType}
        onReset={stableHandlers.resetSubtitleState}
        onExpandHorizontally={stableHandlers.expandHorizontally}
        onMouseEnter={stableHandlers.handleControlsMouseEnter}
        onMouseLeave={stableHandlers.handleControlsMouseLeave}
      />

      {/* Â≠óÂπïÂÆπÂô® */}
      <div
        ref={containerRef}
        className={`${styles.subtitleContainer} ${dragAndResizeProps.isDragging ? styles.dragging : ''}`}
        style={containerStyle}
        onMouseDown={stableHandlers.handleContainerMouseDown}
        onMouseEnter={stableHandlers.handleMouseEnter}
        onMouseLeave={stableHandlers.handleMouseLeave}
      >
        {/* Â≠óÂπïÂÜÖÂÆπÂå∫Âüü */}
        <div
          className={`${styles.subtitleContent} ${
            actualBackgroundType === 'blur'
              ? styles.blurBackground
              : actualBackgroundType === 'solid-black'
                ? styles.solidBlackBackground
                : actualBackgroundType === 'solid-gray'
                  ? styles.solidGrayBackground
                  : styles.transparentBackground
          }`}
        >
          <SubtitleContent
            dynamicTextStyle={dynamicTextStyle}
            dynamicEnglishTextStyle={dynamicEnglishTextStyle}
            dynamicChineseTextStyle={dynamicChineseTextStyle}
            onWordHover={stableHandlers.handleWordHover}
            onWordClick={stableHandlers.handleWordClick}
          />
        </div>

        {/* Ë∞ÉÊï¥Â§ßÂ∞èÊéßÂà∂ÁÇπ */}
        <ResizeHandle
          visible={isHovering}
          buttonSize={buttonSize}
          onMouseDown={stableHandlers.handleResizeMouseDown}
        />
      </div>

      {/* ÂçïËØçÂç°Áâá */}
      {selectedWord && (
        <WordCard
          word={selectedWord.word}
          targetElement={selectedWord.element}
          onClose={stableHandlers.handleCloseWordCard}
        />
      )}
    </>
  )
}

// ‰ΩøÁî®Êõ¥‰∏•Ê†ºÁöÑÊØîËæÉÂáΩÊï∞
const MemoizedSubtitleV3 = memo(SubtitleV3, (prevProps, nextProps) => {
  return (
    prevProps.onWordHover === nextProps.onWordHover &&
    prevProps.onPauseOnHover === nextProps.onPauseOnHover
  )
})

export { MemoizedSubtitleV3 as SubtitleV3 }
