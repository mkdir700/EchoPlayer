# æ’­æ”¾å™¨å¼•æ“ V3 æŠ€æœ¯è§„èŒƒ

## ğŸ“‹ ç›®å½•

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. æ¶æ„è®¾è®¡](#2-æ¶æ„è®¾è®¡)
- [3. çŠ¶æ€æœºè®¾è®¡](#3-çŠ¶æ€æœºè®¾è®¡)
- [4. æ ¸å¿ƒç»„ä»¶è§„èŒƒ](#4-æ ¸å¿ƒç»„ä»¶è§„èŒƒ)
- [5. æ•°æ®æµè®¾è®¡](#5-æ•°æ®æµè®¾è®¡)
- [6. æ¥å£å®šä¹‰](#6-æ¥å£å®šä¹‰)
- [7. é”™è¯¯å¤„ç†](#7-é”™è¯¯å¤„ç†)
- [8. æ€§èƒ½è¦æ±‚](#8-æ€§èƒ½è¦æ±‚)
- [9. æµ‹è¯•ç­–ç•¥](#9-æµ‹è¯•ç­–ç•¥)
- [10. è¿ç§»è®¡åˆ’](#10-è¿ç§»è®¡åˆ’)

## 1. æ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯

å½“å‰æ’­æ”¾å™¨å¼•æ“ï¼ˆV2ï¼‰å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

- å¤æ‚çš„æ„å›¾ç³»ç»Ÿå¯¼è‡´ç»´æŠ¤å›°éš¾
- åˆ†æ•£çš„çŠ¶æ€ç®¡ç†å¢åŠ è°ƒè¯•å¤æ‚åº¦
- å…­é˜¶æ®µæ•°æ®æµé€ æˆæ€§èƒ½å¼€é”€
- ç­–ç•¥ç³»ç»Ÿè¿‡äºæŠ½è±¡ï¼Œéš¾ä»¥ç†è§£

### 1.2 è®¾è®¡ç›®æ ‡

**ä¸»è¦ç›®æ ‡**ï¼š

- ğŸ¯ **ç®€åŒ–æ¶æ„**: ä½¿ç”¨çŠ¶æ€æœºç»Ÿä¸€ç®¡ç†æ’­æ”¾é€»è¾‘
- ğŸ” **æé«˜å¯è°ƒè¯•æ€§**: çŠ¶æ€è½¬æ¢è·¯å¾„æ¸…æ™°ï¼Œæ˜“äºè¿½è¸ª
- âš¡ **ä¼˜åŒ–æ€§èƒ½**: å‡å°‘ä¸å¿…è¦çš„è®¡ç®—å’ŒçŠ¶æ€æ£€æŸ¥
- ğŸ›  **å¢å¼ºå¯ç»´æŠ¤æ€§**: ä»£ç ç»“æ„æ¸…æ™°ï¼ŒèŒè´£åˆ†ç¦»æ˜ç¡®

**æ¬¡è¦ç›®æ ‡**ï¼š

- ä¿æŒå‘åå…¼å®¹æ€§
- æ”¯æŒæ¸è¿›å¼è¿ç§»
- æä¾›æ›´å¥½çš„å¼€å‘ä½“éªŒ

### 1.3 æ ¸å¿ƒåŸåˆ™

1. **å•ä¸€èŒè´£åŸåˆ™**: æ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªç‰¹å®šåŠŸèƒ½
2. **çŠ¶æ€é©±åŠ¨**: æ‰€æœ‰æ’­æ”¾è¡Œä¸ºç”±çŠ¶æ€æœºé©±åŠ¨
3. **äº‹ä»¶é©±åŠ¨**: é€šè¿‡äº‹ä»¶è¿›è¡Œç»„ä»¶é—´é€šä¿¡
4. **å¯é¢„æµ‹æ€§**: ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
5. **å¯æµ‹è¯•æ€§**: æ‰€æœ‰ç»„ä»¶éƒ½èƒ½ç‹¬ç«‹æµ‹è¯•

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ’­æ”¾å™¨å¼•æ“ V3                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç”¨æˆ·æ¥å£å±‚ (Public API)                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚   PlayEngine    â”‚  â”‚   EventEmitter  â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ¸å¿ƒçŠ¶æ€å±‚ (Core State Layer)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ PlayerStateMachine â”‚  â”‚  StateManager   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŠŸèƒ½æ¨¡å—å±‚ (Feature Modules)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ SentenceManager â”‚ â”‚  LoopManager    â”‚ â”‚ AutoController  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ§åˆ¶å±‚ (Control Layer)                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚PlaybackControllerâ”‚  â”‚  EventHandler   â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºç¡€è®¾æ–½å±‚ (Infrastructure)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   MediaClock    â”‚ â”‚    Logger       â”‚ â”‚   TypeDefs      â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 åˆ†å±‚èŒè´£

| å±‚çº§       | èŒè´£               | ç»„ä»¶                                         |
| ---------- | ------------------ | -------------------------------------------- |
| ç”¨æˆ·æ¥å£å±‚ | å¯¹å¤–æä¾›ç»Ÿä¸€API    | PlayEngine, EventEmitter                     |
| æ ¸å¿ƒçŠ¶æ€å±‚ | çŠ¶æ€ç®¡ç†å’Œè½¬æ¢     | PlayerStateMachine, StateManager             |
| åŠŸèƒ½æ¨¡å—å±‚ | å…·ä½“ä¸šåŠ¡é€»è¾‘       | SentenceManager, LoopManager, AutoController |
| æ§åˆ¶å±‚     | è®¾å¤‡æ§åˆ¶å’Œäº‹ä»¶å¤„ç† | PlaybackController, EventHandler             |
| åŸºç¡€è®¾æ–½å±‚ | å…¬å…±æœåŠ¡å’Œå·¥å…·     | MediaClock, Logger, TypeDefs                 |

### 2.3 ä¾èµ–å…³ç³»

```mermaid
graph TD
    A[PlayEngine] --> B[PlayerStateMachine]
    A --> C[EventHandler]
    B --> D[StateManager]
    B --> E[SentenceManager]
    B --> F[LoopManager]
    B --> G[AutoController]
    C --> H[PlaybackController]
    E --> I[MediaClock]
    F --> I
    G --> I
    H --> I
```

## 3. çŠ¶æ€æœºè®¾è®¡

### 3.1 åˆ†å±‚å¹¶è¡ŒçŠ¶æ€æ¶æ„

åŸºäºXState v5è®¾è®¡ï¼Œé‡‡ç”¨åˆ†å±‚å¹¶è¡ŒçŠ¶æ€æœºï¼Œå°†å¤æ‚çš„çº¿æ€§çŠ¶æ€è½¬æ¢ä¸ºé¢†åŸŸåˆ†ç¦»çš„å¹¶è¡Œå­çŠ¶æ€æœºï¼š

```typescript
// åˆ†å±‚å¹¶è¡ŒçŠ¶æ€æ¶æ„
interface PlayerStateMachineSchema {
  value: {
    // å¹¶è¡ŒåŸŸ1ï¼šæ’­æ”¾ä¼ è¾“çŠ¶æ€
    transport: 'playing' | 'paused' | 'buffering' | 'ended' | 'error'
    // å¹¶è¡ŒåŸŸ2ï¼šä½ç½®æ§åˆ¶çŠ¶æ€
    positioning: 'idle' | 'seeking'
    // å¹¶è¡ŒåŸŸ3ï¼šå¥å­è·Ÿè¸ªçŠ¶æ€
    sentence: {
      tracking: 'active' | 'completed' | 'none'
      looping: 'disabled' | 'finite' | 'infinite'
    }
    // å¹¶è¡ŒåŸŸ4ï¼šè‡ªåŠ¨æ§åˆ¶çŠ¶æ€
    autoControl: {
      autoPause: 'off' | 'on'
      autoResume: 'off' | 'arming' | 'counting' | 'triggered'
      gapSkip: 'off' | 'armed' | 'skipping'
    }
    // å¹¶è¡ŒåŸŸ5ï¼šé…ç½®ç¼–æ’çŠ¶æ€
    config: 'idle' | 'applying' | 'rollbacking'
  }
}

// çŠ¶æ€å€¼æšä¸¾ï¼ˆç”¨äºç±»å‹å®‰å…¨ï¼‰
export const PlayerStateValues = {
  transport: {
    PLAYING: 'playing',
    PAUSED: 'paused',
    BUFFERING: 'buffering',
    ENDED: 'ended',
    ERROR: 'error'
  },
  positioning: {
    IDLE: 'idle',
    SEEKING: 'seeking'
  },
  sentence: {
    tracking: {
      ACTIVE: 'active',
      COMPLETED: 'completed',
      NONE: 'none'
    },
    looping: {
      DISABLED: 'disabled',
      FINITE: 'finite',
      INFINITE: 'infinite'
    }
  },
  autoControl: {
    autoPause: {
      OFF: 'off',
      ON: 'on'
    },
    autoResume: {
      OFF: 'off',
      ARMING: 'arming',
      COUNTING: 'counting',
      TRIGGERED: 'triggered'
    },
    gapSkip: {
      OFF: 'off',
      ARMED: 'armed',
      SKIPPING: 'skipping'
    }
  },
  config: {
    IDLE: 'idle',
    APPLYING: 'applying',
    ROLLBACKING: 'rollbacking'
  }
} as const

type PlayerStateValue = PlayerStateMachineSchema['value']
```

### 3.2 å¼ºç±»å‹äº‹ä»¶å®šä¹‰

ä½¿ç”¨Discriminated Unionsæ›¿ä»£æšä¸¾ï¼Œæä¾›ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨å’Œæ›´å¥½çš„å¯æ‰©å±•æ€§ï¼š

```typescript
// å¼ºç±»å‹äº‹ä»¶å®šä¹‰ï¼ˆDiscriminated Unionsï¼‰
export type PlayerEvent =
  // ç”¨æˆ·äº¤äº’äº‹ä»¶
  | { type: 'USER.TOGGLE_PLAY' }
  | { type: 'USER.PLAY' }
  | { type: 'USER.PAUSE' }
  | { type: 'USER.SEEK'; at: number; reason?: 'drag' | 'jump' | 'click' }

  // åª’ä½“çŠ¶æ€äº‹ä»¶
  | { type: 'MEDIA.TIME_UPDATE'; now: number; buffered?: TimeRanges }
  | { type: 'MEDIA.ENDED' }
  | {
      type: 'MEDIA.ERROR'
      error: MediaError
      code: string
      severity: 'low' | 'medium' | 'high' | 'critical'
    }
  | { type: 'MEDIA.BUFFERING'; isBuffering: boolean }
  | { type: 'MEDIA.SEEKING'; at: number }
  | { type: 'MEDIA.SEEKED'; at: number }

  // å¥å­ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
  | { type: 'SENTENCE.STARTED'; index: number; sentence: SubtitleItem }
  | { type: 'SENTENCE.ENDED'; index: number; sentence: SubtitleItem; isLast?: boolean }
  | { type: 'SENTENCE.CHANGED'; from: number; to: number }

  // å¾ªç¯æ§åˆ¶äº‹ä»¶
  | { type: 'LOOP.ENABLE'; mode: LoopMode; count?: number }
  | { type: 'LOOP.DISABLE' }
  | { type: 'LOOP.EXECUTE'; sentenceIndex: number; remaining: number | 'infinite' }
  | { type: 'LOOP.COMPLETED'; totalLoops: number }

  // è‡ªåŠ¨æ§åˆ¶äº‹ä»¶
  | { type: 'AUTO.PAUSE_ENABLE' }
  | { type: 'AUTO.PAUSE_DISABLE' }
  | { type: 'AUTO.RESUME_ENABLE'; delay: number }
  | { type: 'AUTO.RESUME_DISABLE' }
  | { type: 'AUTO.RESUME_TIMEOUT' }
  | { type: 'GAP.SKIP_ENABLE'; threshold: number }
  | { type: 'GAP.SKIP_DISABLE' }
  | { type: 'GAP.DETECTED'; size: number; at: number }
  | { type: 'GAP.SKIPPED'; from: number; to: number }

  // é…ç½®ç®¡ç†äº‹ä»¶
  | {
      type: 'CONFIG.UPDATE_REQUEST'
      patch: Partial<PlayEngineConfig>
      immediate?: boolean
      id: string
    }
  | { type: 'CONFIG.VALIDATE'; config: Partial<PlayEngineConfig>; context: ValidationContext }
  | { type: 'CONFIG.APPLY'; config: Partial<PlayEngineConfig>; snapshot: ConfigSnapshot }
  | { type: 'CONFIG.APPLIED'; config: PlayEngineConfig; changes: ConfigChange[] }
  | { type: 'CONFIG.ROLLBACK'; snapshotId: string; reason: string }
  | { type: 'CONFIG.CONFLICT'; conflicts: ConfigConflict[]; resolution: ConflictResolution }

  // ç³»ç»Ÿäº‹ä»¶
  | { type: 'SYSTEM.INIT'; config: PlayEngineConfig }
  | { type: 'SYSTEM.DISPOSE' }
  | { type: 'SYSTEM.RESET'; reason: 'error' | 'user' | 'config' }

  // å‘½ä»¤é˜Ÿåˆ—äº‹ä»¶
  | { type: 'COMMAND.ENQUEUE'; command: Command }
  | { type: 'COMMAND.EXECUTE'; command: Command }
  | { type: 'COMMAND.COMPLETE'; command: Command; result: any }
  | { type: 'COMMAND.ERROR'; command: Command; error: Error }

// äº‹ä»¶ç±»å‹å®ˆå«
export const isUserEvent = (
  event: PlayerEvent
): event is Extract<PlayerEvent, { type: `USER.${string}` }> => event.type.startsWith('USER.')

export const isMediaEvent = (
  event: PlayerEvent
): event is Extract<PlayerEvent, { type: `MEDIA.${string}` }> => event.type.startsWith('MEDIA.')

export const isSentenceEvent = (
  event: PlayerEvent
): event is Extract<PlayerEvent, { type: `SENTENCE.${string}` }> =>
  event.type.startsWith('SENTENCE.')

// äº‹ä»¶åˆ›å»ºå™¨ï¼ˆå·¥å‚å‡½æ•°ï¼‰
export const createPlayerEvent = {
  userSeek: (at: number, reason?: 'drag' | 'jump' | 'click'): PlayerEvent => ({
    type: 'USER.SEEK',
    at,
    reason
  }),
  mediaTimeUpdate: (now: number, buffered?: TimeRanges): PlayerEvent => ({
    type: 'MEDIA.TIME_UPDATE',
    now,
    buffered
  }),
  sentenceEnded: (index: number, sentence: SubtitleItem, isLast?: boolean): PlayerEvent => ({
    type: 'SENTENCE.ENDED',
    index,
    sentence,
    isLast
  }),
  configUpdate: (patch: Partial<PlayEngineConfig>, immediate?: boolean): PlayerEvent => ({
    type: 'CONFIG.UPDATE_REQUEST',
    patch,
    immediate,
    id: crypto.randomUUID()
  })
}

// æ”¯æŒç±»å‹
interface ValidationContext {
  currentState: PlayerStateValue
  activeCommands: Command[]
  timestamp: number
}

interface ConfigSnapshot {
  id: string
  config: PlayEngineConfig
  timestamp: number
  checksum: string
}

interface ConfigChange {
  key: keyof PlayEngineConfig
  oldValue: any
  newValue: any
  appliedAt: number
}

interface ConfigConflict {
  key: keyof PlayEngineConfig
  currentValue: any
  requestedValue: any
  conflictType: 'state_dependent' | 'value_constraint' | 'logic_conflict'
  resolution: 'queue' | 'immediate' | 'reject' | 'user_confirm'
  message: string
}

type ConflictResolution = 'auto_resolve' | 'queue_pending' | 'user_required' | 'rollback'
```

### 3.3 ä¸Šä¸‹æ–‡å®šä¹‰ï¼ˆContextï¼‰

çŠ¶æ€æœºä¸Šä¸‹æ–‡åŒ…å«å†³ç­–æ‰€éœ€çš„æœ€å°å……åˆ†ä¿¡æ¯ï¼Œé¿å…å†—ä½™å’Œæ´¾ç”ŸçŠ¶æ€ï¼š

```typescript
// çŠ¶æ€æœºä¸Šä¸‹æ–‡
interface PlayerStateMachineContext {
  // æ’­æ”¾çŠ¶æ€
  currentTime: number
  duration: number
  playbackRate: number
  volume: number
  muted: boolean

  // å¥å­çŠ¶æ€
  currentSentenceIndex: number
  sentences: SubtitleItem[]
  sentenceProgress: number // å½“å‰å¥å­æ’­æ”¾è¿›åº¦ 0-1

  // å¾ªç¯çŠ¶æ€
  loopMode: LoopMode
  loopCount: number
  loopRemaining: number | 'infinite'

  // è‡ªåŠ¨æ§åˆ¶çŠ¶æ€
  autoPauseEnabled: boolean
  autoResumeEnabled: boolean
  autoResumeDelay: number
  gapSkipEnabled: boolean
  gapSkipThreshold: number

  // å®šæ—¶å™¨å’Œå¼‚æ­¥æ“ä½œå¥æŸ„
  timers: {
    autoResume: NodeJS.Timeout | null
    gapDetection: NodeJS.Timeout | null
  }
  services: {
    seekOperation: Promise<void> | null
    configValidation: Promise<ValidationResult> | null
  }

  // å‘½ä»¤é˜Ÿåˆ—
  commandQueue: Command[]
  activeCommand: Command | null

  // é…ç½®å¿«ç…§
  configSnapshot: ConfigSnapshot | null
  configHistory: ConfigSnapshot[]

  // é”™è¯¯çŠ¶æ€
  lastError: PlayEngineError | null
  errorCount: number
}

// å‘½ä»¤å®šä¹‰
interface Command {
  id: string
  type: 'play' | 'pause' | 'seek' | 'updateConfig' | 'reset'
  payload?: any
  priority: 'low' | 'normal' | 'high' | 'critical'
  timestamp: number
  timeout?: number
  retryCount?: number
  maxRetries?: number
}

// é…ç½®éªŒè¯ç»“æœ
interface ValidationResult {
  valid: boolean
  errors: ConfigError[]
  warnings: ConfigWarning[]
  conflicts: ConfigConflict[]
}

interface ConfigError {
  key: keyof PlayEngineConfig
  value: any
  message: string
  code: string
}

interface ConfigWarning {
  key: keyof PlayEngineConfig
  message: string
  suggestion?: string
}
```

### 3.4 å¹¶è¡ŒçŠ¶æ€è½¬æ¢é€»è¾‘

åŸºäºåˆ†å±‚å¹¶è¡Œæ¶æ„ï¼ŒçŠ¶æ€è½¬æ¢é€šè¿‡Guardsã€Actionså’ŒServiceså®ç°ï¼š

#### å¹¶è¡ŒåŸŸé—´åè°ƒ

| è§¦å‘åŸŸ                 | äº‹ä»¶                | å½±å“åŸŸ            | åè°ƒé€»è¾‘             | å®ç°æ–¹å¼              |
| ---------------------- | ------------------- | ----------------- | -------------------- | --------------------- |
| transport              | SENTENCE.ENDED      | sentence.tracking | å¥å­å®Œæˆè§¦å‘å¾ªç¯æ£€æŸ¥ | raise internal event  |
| sentence.looping       | LOOP.EXECUTE        | positioning       | å¾ªç¯æ‰§è¡Œè§¦å‘seekæ“ä½œ | invoke seek service   |
| autoControl.autoResume | AUTO.RESUME_TIMEOUT | transport         | è‡ªåŠ¨æ¢å¤è§¦å‘æ’­æ”¾     | send event to parent  |
| config                 | CONFIG.APPLY        | all domains       | é…ç½®åº”ç”¨å½±å“æ‰€æœ‰åŸŸ   | broadcast to children |

#### Guardsï¼ˆå®ˆå«æ¡ä»¶ï¼‰

```typescript
interface PlayerStateMachineGuards {
  // å¾ªç¯ç›¸å…³å®ˆå«
  shouldLoop: (context: PlayerStateMachineContext) => boolean
  hasLoopRemaining: (context: PlayerStateMachineContext) => boolean
  isInfiniteLoop: (context: PlayerStateMachineContext) => boolean

  // è‡ªåŠ¨æ§åˆ¶å®ˆå«
  shouldAutoPause: (context: PlayerStateMachineContext) => boolean
  shouldAutoResume: (context: PlayerStateMachineContext) => boolean
  shouldSkipGap: (context: PlayerStateMachineContext, event: PlayerEvent) => boolean

  // é…ç½®æ›´æ–°å®ˆå«
  canApplyConfigNow: (context: PlayerStateMachineContext, event: PlayerEvent) => boolean
  hasConfigConflicts: (context: PlayerStateMachineContext, event: PlayerEvent) => boolean

  // å¥å­è¾¹ç•Œå®ˆå«
  isLastSentence: (context: PlayerStateMachineContext) => boolean
  hasNextSentence: (context: PlayerStateMachineContext) => boolean
}

// Guards å®ç°ç¤ºä¾‹
const guards: PlayerStateMachineGuards = {
  shouldLoop: ({ loopMode, loopRemaining }) =>
    loopMode !== 'disabled' && (loopRemaining === 'infinite' || loopRemaining > 0),

  shouldAutoPause: ({ autoPauseEnabled }) => autoPauseEnabled,

  canApplyConfigNow: ({ commandQueue, activeCommand }, event) =>
    activeCommand === null && commandQueue.length === 0,

  shouldSkipGap: ({ gapSkipEnabled, gapSkipThreshold }, event) =>
    gapSkipEnabled && isGapDetectionEvent(event) && event.size > gapSkipThreshold
}
```

#### Actionsï¼ˆåŠ¨ä½œï¼‰

```typescript
interface PlayerStateMachineActions {
  // ä¸Šä¸‹æ–‡æ›´æ–°åŠ¨ä½œ
  updateCurrentTime: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  updateSentenceIndex: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  decrementLoopCount: (context: PlayerStateMachineContext) => void

  // å‘½ä»¤é˜Ÿåˆ—åŠ¨ä½œ
  enqueueCommand: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  dequeueCommand: (context: PlayerStateMachineContext) => void

  // é…ç½®ç®¡ç†åŠ¨ä½œ
  saveConfigSnapshot: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  applyConfigPatch: (context: PlayerStateMachineContext, event: PlayerEvent) => void

  // å®šæ—¶å™¨ç®¡ç†åŠ¨ä½œ
  startAutoResumeTimer: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  cancelAutoResumeTimer: (context: PlayerStateMachineContext) => void

  // é”™è¯¯å¤„ç†åŠ¨ä½œ
  recordError: (context: PlayerStateMachineContext, event: PlayerEvent) => void
  clearError: (context: PlayerStateMachineContext) => void
}
```

#### Servicesï¼ˆæœåŠ¡ï¼‰

```typescript
interface PlayerStateMachineServices {
  // å¼‚æ­¥åª’ä½“æ“ä½œ
  seekService: (context: PlayerStateMachineContext, event: PlayerEvent) => Promise<SeekResult>
  playService: (context: PlayerStateMachineContext) => Promise<PlayResult>
  pauseService: (context: PlayerStateMachineContext) => Promise<PauseResult>

  // é…ç½®ç®¡ç†æœåŠ¡
  validateConfigService: (config: Partial<PlayEngineConfig>) => Promise<ValidationResult>
  applyConfigService: (
    context: PlayerStateMachineContext,
    config: Partial<PlayEngineConfig>
  ) => Promise<ConfigResult>

  // é—´éš™æ£€æµ‹æœåŠ¡
  gapDetectionService: (context: PlayerStateMachineContext) => Promise<GapDetectionResult>

  // å¥å­ç®¡ç†æœåŠ¡
  sentenceNavigationService: (target: number | 'next' | 'previous') => Promise<NavigationResult>
}
```

#### Activitiesï¼ˆæ´»åŠ¨ï¼‰

é•¿ç”Ÿå‘½å‘¨æœŸå‰¯ä½œç”¨ç®¡ç†ï¼š

```typescript
interface PlayerStateMachineActivities {
  // æ—¶é’Ÿæ´»åŠ¨
  mediaClockActivity: {
    start: (context: PlayerStateMachineContext) => Subscription
    stop: (subscription: Subscription) => void
  }

  // é…ç½®ç›‘å¬æ´»åŠ¨
  configWatchActivity: {
    start: (context: PlayerStateMachineContext) => Subscription
    stop: (subscription: Subscription) => void
  }

  // æ€§èƒ½ç›‘æ§æ´»åŠ¨
  performanceMonitorActivity: {
    start: (context: PlayerStateMachineContext) => Subscription
    stop: (subscription: Subscription) => void
  }
}

// Subscription æ¥å£
interface Subscription {
  unsubscribe(): void
  closed: boolean
}
```

### 3.5 XState v5 çŠ¶æ€æœºé…ç½®ç¤ºä¾‹

åŸºäºæ–°æ¶æ„çš„å®é™…çŠ¶æ€æœºé…ç½®ï¼š

```typescript
import { setup, createMachine, fromPromise, raise, enqueueActions, choose } from 'xstate'

// XState v5 çŠ¶æ€æœºè®¾ç½®
const playerStateMachine = setup({
  types: {} as {
    context: PlayerStateMachineContext
    events: PlayerEvent
    actors: {
      seekService: { input: { at: number }; output: SeekResult }
      validateConfigService: {
        input: { config: Partial<PlayEngineConfig> }
        output: ValidationResult
      }
      gapDetectionService: { input: {}; output: GapDetectionResult }
    }
  },

  // Guards
  guards: {
    shouldLoop: ({ context }) =>
      context.loopMode !== 'disabled' &&
      (context.loopRemaining === 'infinite' || context.loopRemaining > 0),

    shouldAutoPause: ({ context }) => context.autoPauseEnabled,

    shouldAutoResume: ({ context }) => context.autoResumeEnabled,

    shouldSkipGap: ({ context }, event) => {
      if (!context.gapSkipEnabled) return false
      if (event.type !== 'GAP.DETECTED') return false
      return event.size > context.gapSkipThreshold
    },

    canApplyConfigNow: ({ context }) =>
      context.activeCommand === null && context.commandQueue.length === 0,

    isLastSentence: ({ context }) => context.currentSentenceIndex >= context.sentences.length - 1
  },

  // Actions
  actions: {
    updateCurrentTime: ({ context }, event) => {
      if (event.type === 'MEDIA.TIME_UPDATE') {
        context.currentTime = event.now
      }
    },

    updateSentenceIndex: ({ context }, event) => {
      if (event.type === 'SENTENCE.ENDED') {
        context.currentSentenceIndex = event.index
      }
    },

    decrementLoopCount: ({ context }) => {
      if (typeof context.loopRemaining === 'number' && context.loopRemaining > 0) {
        context.loopRemaining--
      }
    },

    enqueueCommand: ({ context }, event) => {
      if (event.type === 'COMMAND.ENQUEUE') {
        context.commandQueue.push(event.command)
      }
    },

    saveConfigSnapshot: ({ context }) => {
      context.configSnapshot = {
        id: crypto.randomUUID(),
        config: { ...context } as PlayEngineConfig,
        timestamp: Date.now(),
        checksum: generateChecksum(context)
      }
    },

    startAutoResumeTimer: ({ context }) => {
      if (context.timers.autoResume) {
        clearTimeout(context.timers.autoResume)
      }
      context.timers.autoResume = setTimeout(() => {
        // å‘é€è‡ªåŠ¨æ¢å¤äº‹ä»¶
      }, context.autoResumeDelay)
    },

    cancelAutoResumeTimer: ({ context }) => {
      if (context.timers.autoResume) {
        clearTimeout(context.timers.autoResume)
        context.timers.autoResume = null
      }
    },

    recordError: ({ context }, event) => {
      if (event.type === 'MEDIA.ERROR') {
        context.lastError = new PlayEngineError(event.error.message, event.code, event.severity)
        context.errorCount++
      }
    }
  },

  // Actors/Services
  actors: {
    seekService: fromPromise(async ({ input }) => {
      await playbackController.seek(input.at)
      return { success: true, position: input.at }
    }),

    validateConfigService: fromPromise(async ({ input }) => {
      return await configManager.validate(input.config)
    }),

    gapDetectionService: fromPromise(async ({ input }) => {
      // é—´éš™æ£€æµ‹é€»è¾‘
      return { hasGap: false, size: 0 }
    })
  },

  // Activities
  activities: {
    mediaClockActivity: {
      start: ({ context }) => {
        const subscription = mediaClock.subscribe((time) => {
          // å‘é€æ—¶é—´æ›´æ–°äº‹ä»¶
        })
        return { unsubscribe: () => subscription.unsubscribe(), closed: false }
      },
      stop: (subscription) => subscription.unsubscribe()
    }
  }
}).createMachine({
  id: 'playerEngine',
  type: 'parallel', // å¹¶è¡ŒçŠ¶æ€æœº

  context: {
    // åˆå§‹åŒ–ä¸Šä¸‹æ–‡
    currentTime: 0,
    duration: 0,
    playbackRate: 1,
    volume: 1,
    muted: false,

    currentSentenceIndex: -1,
    sentences: [],
    sentenceProgress: 0,

    loopMode: 'disabled',
    loopCount: 0,
    loopRemaining: 0,

    autoPauseEnabled: false,
    autoResumeEnabled: false,
    autoResumeDelay: 2000,
    gapSkipEnabled: false,
    gapSkipThreshold: 1000,

    timers: {
      autoResume: null,
      gapDetection: null
    },
    services: {
      seekOperation: null,
      configValidation: null
    },

    commandQueue: [],
    activeCommand: null,

    configSnapshot: null,
    configHistory: [],

    lastError: null,
    errorCount: 0
  },

  states: {
    // å¹¶è¡ŒåŸŸ1ï¼šæ’­æ”¾ä¼ è¾“çŠ¶æ€
    transport: {
      initial: 'paused',
      states: {
        paused: {
          on: {
            'USER.PLAY': { target: 'playing' },
            'USER.TOGGLE_PLAY': { target: 'playing' }
          }
        },
        playing: {
          entry: ['resumePlayback'],
          activities: ['mediaClockActivity'],
          on: {
            'USER.PAUSE': { target: 'paused' },
            'USER.TOGGLE_PLAY': { target: 'paused' },
            'MEDIA.ENDED': { target: 'ended' },
            'MEDIA.ERROR': { target: 'error', actions: ['recordError'] },
            'MEDIA.TIME_UPDATE': { actions: ['updateCurrentTime'] }
          }
        },
        buffering: {
          on: {
            'MEDIA.TIME_UPDATE': { target: 'playing' }
          }
        },
        ended: {
          type: 'final'
        },
        error: {
          on: {
            'SYSTEM.RESET': { target: 'paused', actions: ['clearError'] }
          }
        }
      }
    },

    // å¹¶è¡ŒåŸŸ2ï¼šä½ç½®æ§åˆ¶çŠ¶æ€
    positioning: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            'USER.SEEK': { target: 'seeking' }
          }
        },
        seeking: {
          invoke: {
            src: 'seekService',
            input: ({ event }) => ({ at: event.at }),
            onDone: { target: 'idle' },
            onError: { target: 'idle', actions: ['recordError'] }
          }
        }
      }
    },

    // å¹¶è¡ŒåŸŸ3ï¼šå¥å­çŠ¶æ€
    sentence: {
      type: 'parallel',
      states: {
        tracking: {
          initial: 'none',
          states: {
            none: {
              on: {
                'SENTENCE.STARTED': { target: 'active', actions: ['updateSentenceIndex'] }
              }
            },
            active: {
              on: {
                'SENTENCE.ENDED': {
                  target: 'completed',
                  actions: ['updateSentenceIndex']
                }
              }
            },
            completed: {
              always: [{ target: 'none', guard: 'isLastSentence' }, { target: 'none' }]
            }
          }
        },

        looping: {
          initial: 'disabled',
          states: {
            disabled: {
              on: {
                'LOOP.ENABLE': { target: 'finite' }
              }
            },
            finite: {
              on: {
                'LOOP.DISABLE': { target: 'disabled' },
                'SENTENCE.ENDED': {
                  actions: [
                    choose([
                      {
                        guard: 'shouldLoop',
                        actions: [
                          'decrementLoopCount',
                          raise({ type: 'LOOP.EXECUTE', sentenceIndex: 0, remaining: 0 })
                        ]
                      }
                    ])
                  ]
                }
              }
            },
            infinite: {
              on: {
                'LOOP.DISABLE': { target: 'disabled' },
                'SENTENCE.ENDED': {
                  actions: [
                    raise({ type: 'LOOP.EXECUTE', sentenceIndex: 0, remaining: 'infinite' })
                  ]
                }
              }
            }
          }
        }
      }
    },

    // å¹¶è¡ŒåŸŸ4ï¼šè‡ªåŠ¨æ§åˆ¶
    autoControl: {
      type: 'parallel',
      states: {
        autoPause: {
          initial: 'off',
          states: {
            off: {
              on: {
                'AUTO.PAUSE_ENABLE': { target: 'on' }
              }
            },
            on: {
              on: {
                'AUTO.PAUSE_DISABLE': { target: 'off' },
                'SENTENCE.ENDED': {
                  actions: [raise({ type: 'USER.PAUSE' })],
                  guard: 'shouldAutoPause'
                }
              }
            }
          }
        },

        autoResume: {
          initial: 'off',
          states: {
            off: {
              on: {
                'AUTO.RESUME_ENABLE': { target: 'arming' }
              }
            },
            arming: {
              on: {
                'AUTO.RESUME_DISABLE': { target: 'off' },
                'USER.PAUSE': { target: 'counting' }
              }
            },
            counting: {
              entry: ['startAutoResumeTimer'],
              exit: ['cancelAutoResumeTimer'],
              after: {
                2000: { target: 'triggered' }
              },
              on: {
                'USER.PLAY': { target: 'off' },
                'AUTO.RESUME_DISABLE': { target: 'off' }
              }
            },
            triggered: {
              entry: [raise({ type: 'USER.PLAY' })],
              always: { target: 'off' }
            }
          }
        },

        gapSkip: {
          initial: 'off',
          states: {
            off: {
              on: {
                'GAP.SKIP_ENABLE': { target: 'armed' }
              }
            },
            armed: {
              on: {
                'GAP.SKIP_DISABLE': { target: 'off' },
                'GAP.DETECTED': {
                  target: 'skipping',
                  guard: 'shouldSkipGap'
                }
              }
            },
            skipping: {
              invoke: {
                src: 'seekService',
                input: ({ event }) => ({ at: event.to }),
                onDone: { target: 'armed' },
                onError: { target: 'armed' }
              }
            }
          }
        }
      }
    },

    // å¹¶è¡ŒåŸŸ5ï¼šé…ç½®ç®¡ç†
    config: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            'CONFIG.UPDATE_REQUEST': {
              target: 'applying',
              guard: 'canApplyConfigNow',
              actions: ['saveConfigSnapshot']
            }
          }
        },
        applying: {
          invoke: {
            src: 'validateConfigService',
            input: ({ event }) => ({ config: event.patch }),
            onDone: {
              target: 'idle',
              actions: ['applyConfigPatch']
            },
            onError: {
              target: 'rollbacking'
            }
          }
        },
        rollbacking: {
          // é…ç½®å›æ»šé€»è¾‘
          always: { target: 'idle' }
        }
      }
    }
  }
})

// è¾…åŠ©å‡½æ•°
function generateChecksum(context: PlayerStateMachineContext): string {
  return btoa(JSON.stringify(context)).slice(0, 16)
}
```

## 4. æ ¸å¿ƒç»„ä»¶è§„èŒƒ

### 4.1 PlayEngine (ä¸»å…¥å£) - å‘½ä»¤é˜Ÿåˆ—æ¶æ„

**èŒè´£**: å¯¹å¤–æä¾›ç»Ÿä¸€APIï¼Œé€šè¿‡å‘½ä»¤é˜Ÿåˆ—ç®¡ç†æ“ä½œé¡ºåºæ€§å’Œå¯æ’¤é”€æ€§

```typescript
interface PlayEngine {
  // ç”Ÿå‘½å‘¨æœŸç®¡ç†
  init(config: PlayEngineConfig): Promise<EngineInitResult>
  dispose(): Promise<void>

  // å‘½ä»¤å¼æ’­æ”¾æ§åˆ¶ï¼ˆæ‰€æœ‰æ“ä½œé€šè¿‡å‘½ä»¤é˜Ÿåˆ—ï¼‰
  play(): Promise<CommandResult>
  pause(): Promise<CommandResult>
  togglePlay(): Promise<CommandResult>
  seek(time: number, reason: SeekReason = 'programmatic'): Promise<CommandResult>

  // çŠ¶æ€æŸ¥è¯¢ï¼ˆåªè¯»æ“ä½œï¼Œä¸ç»è¿‡å‘½ä»¤é˜Ÿåˆ—ï¼‰
  getState(): Readonly<PlayerStateValue>
  getContext(): Readonly<PlayerStateMachineContext>
  getSnapshot(): PlayerSnapshot
  getCurrentTime(): number
  getDuration(): number

  // å¢å¼ºé…ç½®çƒ­æ›´æ–°ï¼ˆåŸå­æ€§å’Œäº‹åŠ¡æ€§ï¼‰
  updateConfig(
    patch: Partial<PlayEngineConfig>,
    options?: ConfigUpdateOptions
  ): Promise<ConfigUpdateResult>
  getConfig(): Readonly<PlayEngineConfig>
  getPendingConfig(): Readonly<Partial<PlayEngineConfig>> | null
  rollbackConfig(snapshotId?: string): Promise<ConfigRollbackResult>
  getConfigHistory(): ReadonlyArray<ConfigSnapshot>

  // å¼ºç±»å‹äº‹ä»¶ç³»ç»Ÿ
  on<K extends keyof PlayEngineEvents>(event: K, listener: PlayEngineEvents[K]): UnsubscribeFunction
  off<K extends keyof PlayEngineEvents>(event: K, listener: PlayEngineEvents[K]): void
  once<K extends keyof PlayEngineEvents>(
    event: K,
    listener: PlayEngineEvents[K]
  ): UnsubscribeFunction

  // å‘½ä»¤é˜Ÿåˆ—ç®¡ç†
  getCommandQueue(): ReadonlyArray<Command>
  cancelCommand(commandId: string): boolean
  clearCommandQueue(): void

  // è°ƒè¯•å’Œè¯Šæ–­æ”¯æŒ
  getDebugInfo(): EngineDebugInfo
  exportStateMachine(): StateMachineExport
  exportEventLog(): EventLogExport
  getPerformanceMetrics(): PerformanceMetrics

  // æ•…éšœæ¢å¤å’Œé‡æ”¾
  exportSnapshot(): EngineSnapshot
  loadSnapshot(snapshot: EngineSnapshot): Promise<void>
  replay(events: PlayerEvent[], fromSnapshot?: EngineSnapshot): Promise<ReplayResult>
}

// æ”¯æŒç±»å‹
type SeekReason = 'user' | 'programmatic' | 'loop' | 'gap_skip' | 'sentence_nav'

interface EngineInitResult {
  success: boolean
  version: string
  capabilities: EngineCapability[]
  errors?: InitError[]
  warnings?: InitWarning[]
}

interface CommandResult {
  success: boolean
  commandId: string
  executionTime: number
  error?: PlayEngineError
  metadata?: Record<string, any>
}

interface ConfigUpdateOptions {
  immediate?: boolean
  validateOnly?: boolean
  timeout?: number
  onConflict?: 'reject' | 'queue' | 'force' | 'user_confirm'
  rollbackOnFailure?: boolean
}

interface PlayerSnapshot {
  state: PlayerStateValue
  context: PlayerStateMachineContext
  timestamp: number
  version: string
  checksum: string
}

type UnsubscribeFunction = () => void
type EngineCapability = 'seek' | 'loop' | 'auto_pause' | 'gap_skip' | 'config_hot_reload'

interface InitError {
  code: string
  message: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  component?: string
}

interface InitWarning {
  code: string
  message: string
  suggestion?: string
}
```

**å®ç°è¦æ±‚**:

- å¿…é¡»ä½¿ç”¨ TypeScript ä¸¥æ ¼æ¨¡å¼
- æ‰€æœ‰å…¬å…±æ–¹æ³•å¿…é¡»æœ‰ JSDoc æ³¨é‡Š
- é”™è¯¯å¤„ç†å¿…é¡»é€šè¿‡ Promise reject æˆ–äº‹ä»¶å½¢å¼
- å¿…é¡»æ”¯æŒå¼‚æ­¥åˆå§‹åŒ–å’Œæ¸…ç†

### 4.2 PlayerStateMachine (çŠ¶æ€æœº) - çº¯å†³ç­–å¼•æ“

**èŒè´£**: ç®¡ç†çŠ¶æ€è½¬æ¢é€»è¾‘ï¼Œä¸ç›´æ¥æ‰§è¡Œå‰¯ä½œç”¨ï¼Œæ‰€æœ‰IOæ“ä½œé€šè¿‡Serviceså®ç°

```typescript
interface PlayerStateMachine {
  // çŠ¶æ€æŸ¥è¯¢ï¼ˆåªè¯»ï¼‰
  getCurrentState(): PlayerStateValue
  getContext(): Readonly<PlayerStateMachineContext>
  getSnapshot(): StateMachineSnapshot

  // äº‹ä»¶å‘é€ï¼ˆçº¯å‡½æ•°ï¼‰
  send(event: PlayerEvent): StateMachineSnapshot
  canSend(event: PlayerEvent): boolean

  // çŠ¶æ€ç›‘å¬ï¼ˆåªä¸ºå¯è§‚æµ‹æ€§ï¼‰
  subscribe(observer: StateMachineObserver): Subscription
  onTransition(listener: TransitionListener): Subscription
  onStateChange(listener: StateChangeListener): Subscription

  // ç”Ÿå‘½å‘¨æœŸç®¡ç†
  start(): StateMachineSnapshot
  stop(): void
  restart(snapshot?: StateMachineSnapshot): StateMachineSnapshot

  // è°ƒè¯•å’Œè¯Šæ–­
  getStateHistory(): ReadonlyArray<StateTransitionRecord>
  getMetrics(): StateMachineMetrics
  exportDefinition(): StateMachineDefinition
  validateTransition(from: PlayerStateValue, event: PlayerEvent): TransitionValidationResult

  // æ—¶é—´æ—…è¡Œè°ƒè¯•
  getTransitionPath(targetState: PlayerStateValue): TransitionPath | null
  canReach(targetState: PlayerStateValue): boolean
  simulate(events: PlayerEvent[]): SimulationResult
}

// æ”¯æŒæ¥å£
interface StateMachineSnapshot {
  value: PlayerStateValue
  context: PlayerStateMachineContext
  event: PlayerEvent
  timestamp: number
  changed: boolean
  done: boolean
  can: (event: PlayerEvent) => boolean
}

interface StateMachineObserver {
  next: (snapshot: StateMachineSnapshot) => void
  error?: (error: Error) => void
  complete?: () => void
}

type StateChangeListener = (
  state: PlayerStateValue,
  event: PlayerEvent,
  context: PlayerStateMachineContext
) => void

type TransitionListener = (transition: StateTransitionRecord) => void

interface StateTransitionRecord {
  from: PlayerStateValue
  to: PlayerStateValue
  event: PlayerEvent
  timestamp: number
  duration: number
  guards: GuardEvaluation[]
  actions: ActionExecution[]
}

interface GuardEvaluation {
  name: string
  result: boolean
  duration: number
  error?: Error
}

interface ActionExecution {
  name: string
  success: boolean
  duration: number
  error?: Error
  sideEffects: SideEffect[]
}

interface SideEffect {
  type: 'service_invoke' | 'activity_start' | 'activity_stop' | 'timer_set' | 'timer_clear'
  target: string
  payload?: any
}

interface TransitionValidationResult {
  valid: boolean
  guards: GuardValidation[]
  actions: ActionValidation[]
  path: string[]
  issues: ValidationIssue[]
}

interface SimulationResult {
  finalState: PlayerStateValue
  transitions: StateTransitionRecord[]
  errors: Error[]
  duration: number
  stateChanges: number
}
```

**æŠ€æœ¯è¦æ±‚**:

- ä½¿ç”¨ XState åº“å®ç°
- çŠ¶æ€è½¬æ¢å¿…é¡»æ˜¯ç¡®å®šæ€§çš„
- å¿…é¡»æ”¯æŒçŠ¶æ€å†å²è®°å½•
- å¿…é¡»æä¾›å¯è§†åŒ–è°ƒè¯•æ”¯æŒ

### 4.3 SentenceManager (å¥å­ç®¡ç†) - çº¯è®¡ç®—å¼•æ“

**èŒè´£**: åªè´Ÿè´£å¥å­æŸ¥è¯¢ã€è¾¹ç•Œæ£€æµ‹å’Œå¯¼èˆªè®¡ç®—ï¼Œä¸æ‰§è¡Œå®é™…è·³è½¬æ“ä½œ

```typescript
interface SentenceManager {
  // å¥å­æŸ¥è¯¢ (å¤ç”¨ V2 SubtitleIndexCalculator O(log n) ç®—æ³•)
  getCurrentSentence(time: number): SubtitleItem | null
  getSentenceByIndex(index: number): ReadonlySubtitleItem | null
  getSentenceByTime(time: number): ReadonlySubtitleItem | null
  findSentenceIndex(time: number): number

  // å¥å­é›†åˆæŸ¥è¯¢
  getSentences(): ReadonlyArray<SubtitleItem>
  getSentenceCount(): number
  getNeighboringSentences(index: number, radius: number = 1): NeighboringSentences
  getSentencesInRange(startTime: number, endTime: number): ReadonlyArray<SubtitleItem>

  // è¾¹ç•Œæ£€æµ‹å’Œè¿›åº¦è®¡ç®— (å¤ç”¨ V2 TimeMath EPS é€»è¾‘)
  checkSentenceStart(currentTime: number, targetIndex: number): BoundaryCheck
  checkSentenceEnd(currentTime: number, targetIndex: number): BoundaryCheck
  calculateProgress(currentTime: number, sentenceIndex: number): SentenceProgress
  getNextBoundary(currentTime: number): BoundaryInfo | null

  // å¯¼èˆªè®¡ç®— (ä¸æ‰§è¡Œå®é™…è·³è½¬ï¼Œåªè¿”å›ç›®æ ‡ä¿¡æ¯)
  calculateNextSentence(currentIndex: number): NavigationTarget | null
  calculatePreviousSentence(currentIndex: number): NavigationTarget | null
  calculateSentenceJump(fromIndex: number, toIndex: number): NavigationPlan

  // é—´éš™æ£€æµ‹å’Œåˆ†æ
  detectGap(fromTime: number, toTime: number): GapAnalysis
  getGapsBetweenSentences(): ReadonlyArray<GapInfo>
  calculateOptimalSkipTarget(currentTime: number, threshold: number): SkipTarget | null

  // è™šæ‹Ÿå¥å­æ”¯æŒï¼ˆæ— å­—å¹•åœºæ™¯ï¼‰
  generateVirtualSentences(duration: number, segmentLength: number = 5000): ReadonlyArray<VirtualSubtitleItem>
  isVirtualSentence(sentence: SubtitleItem): boolean

  // é…ç½®æ›´æ–°
  updateSentences(sentences: ReadonlyArray<SubtitleItem>): SentenceUpdateResult
  validateSentences(sentences: ReadonlyArray<SubtitleItem>): SentenceValidationResult

  // æ€§èƒ½å’Œè¯Šæ–­
  getIndexingMetrics(): IndexingMetrics
  rebuildIndex(): IndexRebuildResult
  validateIndex(): IndexValidationResult
}

// æ”¯æŒç±»å‹
interface ReadonlySubtitleItem extends Readonly<SubtitleItem> {}

interface NeighboringSentences {
  previous: ReadonlyArray<SubtitleItem>;
  current: SubtitleItem | null;
  next: ReadonlyArray<SubtitleItem>;
  totalRange: { startTime: number; endTime: number };
}

interface BoundaryCheck {
  atBoundary: boolean;
  distance: number; // æ¯«ç§’ï¼Œè´Ÿå€¼è¡¨ç¤ºè¿‡å»ï¼Œæ­£å€¼è¡¨ç¤ºæœªæ¥
  confidence: number; // 0-1ï¼Œè¾¹ç•Œæ£€æµ‹çš„ç²¾åº¦
  reason: 'exact' | 'epsilon' | 'prediction' | 'none';
}

interface SentenceProgress {
  index: number;
  progress: number; // 0-1
  elapsed: number; // å·²æ’­æ”¾æ¯«ç§’
  remaining: number; // å‰©ä½™æ¯«ç§’
  estimatedEnd: number; // é¢„è®¡ç»“æŸæ—¶é—´
}

interface BoundaryInfo {
  type: 'start' | 'end';
  sentenceIndex: number;
  timestamp: number;
  distance: number;
}

interface NavigationTarget {
  index: number;
  sentence: SubtitleItem;
  seekTarget: number; // å»ºè®®è·³è½¬ä½ç½®
  distance: number; // ä»å½“å‰ä½ç½®çš„è·ç¦»
}

interface NavigationPlan {
  fromIndex: number;
  toIndex: number;
  seekTarget: number;
  crossedSentences: number;
  estimatedDuration: number;
  warnings: string[];
}

interface GapAnalysis {
  hasGap: boolean;
  gapSize: number;
  gapStart: number;
  gapEnd: number;
  confidence: number;
  shouldSkip: boolean;
  reason: string;
}

interface GapInfo {
  beforeSentence: number;
  afterSentence: number;
  startTime: number;
  endTime: number;
  duration: number;
  type: 'silence' | 'pause' | 'chapter_break' | 'unknown';
}

interface SkipTarget {
  targetTime: number;
  targetSentence: number;
  skippedDuration: number;
  reason: string;
  confidence: number;
}

interface VirtualSubtitleItem extends SubtitleItem {
  virtual: true;
  segmentIndex: number;
}

  // é…ç½®ç®¡ç†
  updateSubtitles(subtitles: SubtitleItem[]): void
  setCurrentIndex(index: number): void

  // äº‹ä»¶å‘é€
  onSentenceChange: EventEmitter<SentenceChangeEvent>
  onSentenceEnd: EventEmitter<SentenceEndEvent>
}
```

**å®ç°è¦æ±‚**:

- å¿…é¡»æ”¯æŒé«˜ç²¾åº¦æ—¶é—´æ¯”è¾ƒ (å¤ç”¨ V2 TimeMath.EPS å’Œè¾¹ç•Œæ£€æµ‹ç®—æ³•)
- å¥å­è¾¹ç•Œæ£€æµ‹å¿…é¡»ç¨³å®šï¼Œé¿å…æŠ–åŠ¨ (å¤ç”¨ V2 çš„è¾¹ç•ŒæŠ–åŠ¨æ£€æµ‹é€»è¾‘)
- å¿…é¡»æ”¯æŒç©ºå­—å¹•åœºæ™¯
- æ€§èƒ½è¦æ±‚ï¼šO(log n) æ—¶é—´å¤æ‚åº¦æŸ¥æ‰¾ (å¤ç”¨ V2 SubtitleIndexCalculator çš„äºŒåˆ†æœç´¢)

### 4.4 LoopManager (å¾ªç¯ç®¡ç†) - çº¯çŠ¶æ€ç®¡ç†

**èŒè´£**: åªç®¡ç†å¾ªç¯çŠ¶æ€å’Œé€»è¾‘åˆ¤æ–­ï¼Œä¸æ‰§è¡Œseekæ“ä½œ

```typescript
interface LoopManager {
  // å¾ªç¯é…ç½®ç®¡ç†
  configure(config: LoopConfiguration): LoopConfigResult
  getConfiguration(): Readonly<LoopConfiguration>
  validateConfiguration(config: Partial<LoopConfiguration>): ValidationResult

  // å¾ªç¯çŠ¶æ€æŸ¥è¯¢
  getCurrentState(): Readonly<LoopState>
  shouldLoop(context: LoopContext): LoopDecision
  calculateNextLoop(currentLoop: number): LoopCalculation

  // å¾ªç¯è®¡æ•°ç®¡ç†
  initializeLoop(mode: LoopMode, count?: number): LoopInitResult
  decrementLoop(): LoopDecrementResult
  resetLoop(): LoopResetResult
  completeLoop(): LoopCompletionResult

  // å¾ªç¯è¿›åº¦è·Ÿè¸ª
  getLoopProgress(): LoopProgress
  getLoopHistory(): ReadonlyArray<LoopRecord>
  getLoopStatistics(): LoopStatistics

  // å¾ªç¯ç­–ç•¥è®¡ç®—
  calculateLoopStrategy(sentenceIndex: number, duration: number): LoopStrategy
  evaluateLoopConditions(context: LoopEvaluationContext): LoopEvaluation
  predictLoopBehavior(scenario: LoopScenario): LoopPrediction

  // äº‹ä»¶ç›‘å¬å’ŒçŠ¶æ€æ›´æ–°
  subscribe(observer: LoopObserver): Subscription
  getStateChangeEvents(): ReadonlyArray<LoopStateChangeEvent>
}
```

**å®ç°è¦æ±‚**:

- æ”¯æŒæœ‰é™å¾ªç¯å’Œæ— é™å¾ªç¯
- å¾ªç¯è®¡æ•°å¿…é¡»æŒä¹…åŒ–
- å¿…é¡»ä¸ SentenceManager ååŒå·¥ä½œ
- å¾ªç¯æ‰§è¡Œå¿…é¡»æ˜¯åŸå­æ“ä½œ

### 4.5 AutoController (è‡ªåŠ¨æ§åˆ¶) - ç­–ç•¥è¯„ä¼°å¼•æ“

**èŒè´£**: è¯„ä¼°è‡ªåŠ¨æ§åˆ¶ç­–ç•¥å’Œç®—æ³•ï¼Œä¸æ‰§è¡Œå®é™…æ“ä½œ

```typescript
interface AutoController {
  // é…ç½®ç®¡ç†
  configure(config: AutoControlConfiguration): AutoControlResult
  getConfiguration(): Readonly<AutoControlConfiguration>
  validateConfiguration(config: Partial<AutoControlConfiguration>): ValidationResult

  // è‡ªåŠ¨æš‚åœè¯„ä¼°
  shouldAutoPause(context: AutoPauseContext): AutoPauseDecision
  calculatePauseStrategy(sentenceEnd: SentenceEndContext): PauseStrategy
  evaluatePauseTiming(context: PauseTimingContext): TimingEvaluation

  // è‡ªåŠ¨æ¢å¤è¯„ä¼°
  shouldAutoResume(context: AutoResumeContext): AutoResumeDecision
  calculateResumeDelay(pauseContext: PauseContext): ResumeDelayCalculation
  evaluateResumeConditions(context: ResumeConditionContext): ConditionEvaluation

  // é—´éš™æ£€æµ‹å’Œåˆ†æ
  analyzeGap(gapContext: GapAnalysisContext): GapAnalysisResult
  shouldSkipGap(gapInfo: GapInfo, threshold: number): GapSkipDecision
  calculateSkipStrategy(gap: GapInfo): GapSkipStrategy

  // æ™ºèƒ½ç­–ç•¥è®¡ç®—
  calculateOptimalStrategy(userBehavior: UserBehaviorProfile): OptimalStrategy
  predictUserIntent(interactionHistory: InteractionHistory): IntentPrediction
  adaptToUserPreferences(preferences: UserPreferences): AdaptationResult

  // çŠ¶æ€è¯„ä¼°å’Œç›‘æ§
  getCurrentState(): Readonly<AutoControlState>
  evaluateCurrentStrategy(): StrategyEvaluation
  getPerformanceMetrics(): AutoControlMetrics

  // äº‹ä»¶ç›‘å¬
  subscribe(observer: AutoControlObserver): Subscription
  getDecisionEvents(): ReadonlyArray<AutoControlDecisionEvent>
}
```

**å®ç°è¦æ±‚**:

- å®šæ—¶å™¨å¿…é¡»å¯å–æ¶ˆå’Œé‡ç½®
- é—´éš™æ£€æµ‹å¿…é¡»å¯é…ç½®é˜ˆå€¼
- æ‰€æœ‰è‡ªåŠ¨æ“ä½œå¿…é¡»å¯æ‰‹åŠ¨ä¸­æ–­
- å¿…é¡»å¤„ç†ç»„ä»¶é”€æ¯æ—¶çš„æ¸…ç†

### 4.6 PlaybackController (æ’­æ”¾æ§åˆ¶) - çº¯IOé€‚é…å™¨

**èŒè´£**: çº¯ç²¹çš„åª’ä½“IOé€‚é…å™¨ï¼Œå°è£…æ‰€æœ‰åª’ä½“å…ƒç´ æ“ä½œï¼Œä¸æŒæœ‰çŠ¶æ€

```typescript
interface PlaybackController {
  // è¿æ¥ç®¡ç† (ä» V2 VideoController æ‰©å±•)
  connect(videoElement: HTMLVideoElement): void
  disconnect(): void
  isConnected(): boolean

  // æ’­æ”¾æ§åˆ¶ (å¤ç”¨ V2 VideoController æ¥å£)
  play(): Promise<void>
  pause(): void
  seek(time: number): void

  // çŠ¶æ€æŸ¥è¯¢ (å¤ç”¨ V2 VideoController æ¥å£)
  getCurrentTime(): number
  getDuration(): number
  isPaused(): boolean
  getPlaybackRate(): number
  getVolume(): number

  // å±æ€§è®¾ç½® (å¤ç”¨ V2 VideoController æ¥å£)
  setPlaybackRate(rate: number): void
  setVolume(volume: number): void
  setMuted(muted: boolean): void

  // äº‹ä»¶ç›‘å¬ (åŸºäº V2 MediaClock äº‹ä»¶ç³»ç»Ÿè®¾è®¡)
  onTimeUpdate: EventEmitter<TimeUpdateEvent>
  onPlay: EventEmitter<PlayEvent>
  onPause: EventEmitter<PauseEvent>
  onSeeking: EventEmitter<SeekingEvent>
  onSeeked: EventEmitter<SeekedEvent>
  onEnded: EventEmitter<EndedEvent>
  onError: EventEmitter<ErrorEvent>
}
```

**å®ç°è¦æ±‚**:

- å¿…é¡»å¤„ç†è§†é¢‘å…ƒç´ çš„æ‰€æœ‰å¼‚å¸¸æƒ…å†µ
- æ’­æ”¾æ“ä½œå¿…é¡»è¿”å› Promise
- å¿…é¡»æ”¯æŒè¿æ¥çŠ¶æ€æ£€æŸ¥
- æ‰€æœ‰äº‹ä»¶å¿…é¡»å»é‡å’ŒèŠ‚æµ (å¤ç”¨ V2 MediaClock çš„å»é‡é€»è¾‘)

### 4.7 ConfigManager (é…ç½®ç®¡ç†) - äº‹åŠ¡åŒ–é…ç½®ç³»ç»Ÿ

**èŒè´£**: åŸå­æ€§é…ç½®ç®¡ç†å’ŒSchemaé©±åŠ¨çš„çƒ­æ›´æ–°ç³»ç»Ÿ

````typescript
interface ConfigManager {
  // é…ç½®åˆ†ç±»å’Œæ›´æ–°
  updateConfig(key: string, value: any, immediate?: boolean): Promise<ConfigUpdateResult>
  getConfig(): PlayEngineConfig
  getPendingConfig(): Partial<PlayEngineConfig>

  // é…ç½®åº”ç”¨æ—¶æœº
  canApplyConfigAt(state: PlayerState): boolean
  getOptimalUpdateTiming(): PlayerState[]

  // å†²çªå¤„ç†
  validateConfig(config: Partial<PlayEngineConfig>): ConfigValidationResult
  resolveConflict(currentState: PlayerState, newConfig: any): ConflictResolution

  // é…ç½®å†å²å’Œå›æ»š
  saveConfigSnapshot(): void
  rollbackConfig(): boolean
  getConfigHistory(): ConfigSnapshot[]

  // äº‹ä»¶å‘é€
  onConfigChanged: EventEmitter<ConfigChangeEvent>
  onConfigConflict: EventEmitter<ConfigConflictEvent>
}

**å¢å¼ºé…ç½®çƒ­æ›´æ–°æœºåˆ¶**ï¼š

#### æ—¶æœºç­–ç•¥è¡¨ï¼ˆTiming Matrixï¼‰

åŸºäºZod Schemaé©±åŠ¨çš„é…ç½®çƒ­æ›´æ–°ç³»ç»Ÿï¼Œä½¿ç”¨è¡¨é©±åŠ¨çš„æ—¶æœºç­–ç•¥ï¼š

```typescript
// Schema-first é…ç½®å®šä¹‰
const PlayEngineConfigSchema = z.object({
  // ç«‹å³ç”Ÿæ•ˆé…ç½®
  volume: z.number().min(0).max(1),
  playbackRate: z.number().min(0.5).max(3),
  muted: z.boolean(),

  // å»¶è¿Ÿç”Ÿæ•ˆé…ç½®
  loopEnabled: z.boolean(),
  loopMode: z.enum(['single', 'playlist', 'random']),
  loopCount: z.number().int().min(0),
  autoPauseEnabled: z.boolean(),
  autoResumeEnabled: z.boolean(),
  autoResumeDelay: z.number().int().min(0).max(10000),
  gapSkipEnabled: z.boolean(),
  gapSkipThreshold: z.number().int().min(0).max(10000)
});

// æ—¶æœºç­–ç•¥è¡¨ï¼ˆè¡¨é©±åŠ¨ï¼‰
const ConfigTimingMatrix: Record<
  keyof PlayEngineConfig,
  Record<string, ConfigTimingStrategy>
> = {
  // ç«‹å³ç”Ÿæ•ˆé…ç½®
  volume: {
    '*': { action: 'apply', priority: 10, rollbackable: true }
  },
  playbackRate: {
    'transport.playing': { action: 'apply', priority: 10, rollbackable: true },
    'transport.paused': { action: 'apply', priority: 10, rollbackable: true },
    'transport.buffering': { action: 'queue', delay: 100, priority: 8, rollbackable: true }
  },

  // å»¶è¿Ÿç”Ÿæ•ˆé…ç½®
  loopEnabled: {
    'sentence.tracking.completed': { action: 'apply', priority: 7, rollbackable: true },
    'transport.paused': { action: 'apply', priority: 7, rollbackable: true },
    'sentence.looping.finite': { action: 'queue', priority: 5, conditions: ['loop_cycle_end'], rollbackable: true },
    'sentence.looping.infinite': { action: 'queue', priority: 3, conditions: ['user_confirm'], rollbackable: true },
    '*': { action: 'queue', priority: 1, rollbackable: true }
  },

  autoPauseEnabled: {
    'autoControl.autoPause.off': { action: 'apply', priority: 8, rollbackable: true },
    'autoControl.autoResume.counting': { action: 'apply', priority: 6, conditions: ['immediate_resume'], rollbackable: true },
    '*': { action: 'apply', priority: 5, rollbackable: true }
  }
};

// æ—¶æœºç­–ç•¥å®šä¹‰
interface ConfigTimingStrategy {
  action: 'apply' | 'queue' | 'reject' | 'confirm';
  priority: number;
  delay?: number;
  conditions?: TimingCondition[];
  rollbackable: boolean;
  metadata?: {
    reason?: string;
    alternatives?: AlternativeStrategy[];
  };
}

type TimingCondition =
  | 'loop_cycle_end'
  | 'user_confirm'
  | 'immediate_resume'
  | 'safe_state'
  | 'no_active_commands';

// é…ç½®å†²çªæ£€æµ‹å’Œè§£å†³
function detectConfigConflicts(
  changes: ConfigChange[],
  currentState: PlayerStateValue
): ConfigConflictAnalysis {
  const conflicts: ConfigConflict[] = [];

  changes.forEach(change => {
    const strategy = getTimingStrategy(change.key, currentState);
    const validationResult = validateConfigChange(change, currentState);

    if (!validationResult.valid) {
      conflicts.push({
        key: change.key,
        currentValue: change.oldValue,
        newValue: change.newValue,
        conflictType: validationResult.conflictType,
        resolution: strategy.action,
        severity: validationResult.severity,
        message: validationResult.message,
        suggestedTiming: validationResult.suggestedTiming
      });
    }
  });

  return {
    hasConflicts: conflicts.length > 0,
    conflicts,
    resolutionPlan: generateResolutionPlan(conflicts),
    estimatedResolutionTime: calculateResolutionTime(conflicts)
  };
}

// å†²çªç±»å‹å¢å¼º
interface ConfigConflict {
  key: keyof PlayEngineConfig;
  currentValue: any;
  newValue: any;
  conflictType: 'state_dependent' | 'value_constraint' | 'logic_conflict' | 'timing_conflict';
  resolution: 'queue' | 'apply' | 'reject' | 'confirm';
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  suggestedTiming?: PlayerStateValue;
  metadata?: {
    estimatedDelay?: number;
    alternatives?: string[];
    userActionRequired?: boolean;
  };
}

#### åŸå­å¿«ç…§æœºåˆ¶ï¼ˆAtomic Snapshot + WALï¼‰

```typescript
// åŸå­å¿«ç…§å®šä¹‰
interface AtomicConfigSnapshot {
  id: string;
  timestamp: number;
  config: PlayEngineConfig;
  state: PlayerStateValue;
  context: Partial<PlayerStateMachineContext>;
  checksum: string;
  version: string;
  metadata: {
    createdBy: 'auto' | 'manual' | 'transaction';
    tags: string[];
    description?: string;
    relatedTransactions: string[];
  };
}

// WAL (å†™å…¥æ—¥å¿—) ç³»ç»Ÿ
interface ConfigWALEntry {
  id: string;
  type: 'BEGIN' | 'CHANGE' | 'COMMIT' | 'ROLLBACK' | 'CHECKPOINT';
  timestamp: number;
  transactionId: string;
  data: {
    operation?: ConfigOperation;
    snapshot?: AtomicConfigSnapshot;
    error?: ConfigError;
  };
  checksum: string;
  previousEntry?: string;
}

interface ConfigOperation {
  type: 'SET' | 'DELETE' | 'MERGE';
  key: keyof PlayEngineConfig;
  oldValue: any;
  newValue: any;
  reason: string;
  metadata: OperationMetadata;
}

// äº‹åŠ¡åŒ–é…ç½®æ›´æ–°
class ConfigTransaction {
  private walEntries: ConfigWALEntry[] = [];
  private snapshots: AtomicConfigSnapshot[] = [];

  async begin(): Promise<string> {
    const snapshot = await this.createSnapshot();
    const walEntry: ConfigWALEntry = {
      id: crypto.randomUUID(),
      type: 'BEGIN',
      timestamp: Date.now(),
      transactionId: this.id,
      data: { snapshot },
      checksum: this.calculateChecksum({ snapshot }),
      previousEntry: this.getLastWALEntry()?.id
    };

    await this.writeWALEntry(walEntry);
    return walEntry.id;
  }

  async applyChanges(changes: ConfigChange[]): Promise<TransactionResult> {
    try {
      // 1. é¢„éªŒè¯æ‰€æœ‰å˜æ›´
      const validation = await this.validateAllChanges(changes);
      if (!validation.valid) {
        throw new ConfigValidationError(validation.errors);
      }

      // 2. åˆ›å»ºæ£€æŸ¥ç‚¹
      const checkpoint = await this.createCheckpoint();

      // 3. åŸå­æ€§åº”ç”¨æ‰€æœ‰å˜æ›´
      const results: ConfigChangeResult[] = [];
      for (const change of changes) {
        const result = await this.applyChange(change);
        results.push(result);

        if (!result.success) {
          await this.rollbackToCheckpoint(checkpoint.id);
          throw new ConfigApplicationError(result.error);
        }
      }

      // 4. æäº¤äº‹åŠ¡
      await this.commit();

      return {
        success: true,
        transactionId: this.id,
        appliedChanges: results,
        finalSnapshot: await this.createSnapshot(),
        executionTime: Date.now() - this.startTime
      };

    } catch (error) {
      await this.rollback();
      throw error;
    }
  }

  async rollback(): Promise<void> {
    const initialSnapshot = this.snapshots[0];
    if (initialSnapshot) {
      await this.restoreFromSnapshot(initialSnapshot.id);
    }

    const walEntry: ConfigWALEntry = {
      id: crypto.randomUUID(),
      type: 'ROLLBACK',
      timestamp: Date.now(),
      transactionId: this.id,
      data: { snapshot: initialSnapshot },
      checksum: this.calculateChecksum({ snapshot: initialSnapshot })
    };

    await this.writeWALEntry(walEntry);
  }
}

// é…ç½®å·®å¼‚å’Œåˆå¹¶
function diffConfig(from: PlayEngineConfig, to: Partial<PlayEngineConfig>): ConfigDiff {
  const changes: ConfigChange[] = [];
  const keys = Object.keys(to) as (keyof PlayEngineConfig)[];

  keys.forEach(key => {
    if (from[key] !== to[key]) {
      changes.push({
        key,
        operation: 'SET',
        oldValue: from[key],
        newValue: to[key],
        path: key,
        timestamp: Date.now()
      });
    }
  });

  return {
    changes,
    hasChanges: changes.length > 0,
    affectedKeys: changes.map(c => c.key),
    complexity: calculateDiffComplexity(changes)
  };
}

// é…ç½®åˆå¹¶ç­–ç•¥
function mergeConfigs(
  base: PlayEngineConfig,
  changes: Partial<PlayEngineConfig>,
  strategy: MergeStrategy = 'overwrite'
): ConfigMergeResult {
  const merged = { ...base };
  const conflicts: ConfigConflict[] = [];

  Object.keys(changes).forEach(key => {
    const typedKey = key as keyof PlayEngineConfig;
    const baseValue = base[typedKey];
    const newValue = changes[typedKey];

    if (strategy === 'safe' && hasConflict(baseValue, newValue)) {
      conflicts.push(createConflict(typedKey, baseValue, newValue));
    } else {
      merged[typedKey] = newValue as any;
    }
  });

  return {
    config: merged,
    conflicts,
    hasConflicts: conflicts.length > 0,
    strategy
  };
}

// å¢å¼ºå®ç°è¦æ±‚
/**
 * å¢å¼ºé…ç½®çƒ­æ›´æ–°å®ç°è¦æ±‚ï¼š
 *
 * 1. **åŸå­æ€§**: æ‰€æœ‰é…ç½®æ›´æ–°éƒ½æ˜¯åŸå­æ“ä½œï¼ŒæˆåŠŸæˆ–å¤±è´¥
 * 2. **äº‹åŠ¡æ€§**: æ”¯æŒWALæ—¥å¿—å’Œå¿«ç…§æœºåˆ¶ï¼Œå¯é‡æ”¾å’Œæ¢å¤
 * 3. **Schemaé©±åŠ¨**: æ‰€æœ‰é…ç½®éƒ½é€šè¿‡Zod SchemaéªŒè¯
 * 4. **æ—¶æœºç­–ç•¥**: è¡¨é©±åŠ¨çš„æ—¶æœºå†³ç­–ï¼Œæ ¹æ®çŠ¶æ€é€‰æ‹©æœ€ä¼˜æ—¶æœº
 * 5. **å†²çªè§£å†³**: æ™ºèƒ½å†²çªæ£€æµ‹å’Œå¤šç­–ç•¥è§£å†³
 * 6. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„äº‹ä»¶æ—¥å¿—å’ŒæŒ‡æ ‡ç›‘æ§
 * 7. **æ€§èƒ½ä¼˜åŒ–**: æ‰¹é‡æ›´æ–°ã€å»¶è¿Ÿåˆå¹¶å’Œç¼“å­˜ä¼˜åŒ–
 * 8. **ç”¨æˆ·ä½“éªŒ**: ä¿è¯æ›´æ–°è¿‡ç¨‹ä¸­æ’­æ”¾ä½“éªŒçš„è¿ç»­æ€§
 */

#### é…ç½®çƒ­æ›´æ–°ä½¿ç”¨ç¤ºä¾‹

```typescript
// åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
const configManager = new ConfigManager({
  schema: PlayEngineConfigSchema,
  timingMatrix: ConfigTimingMatrix,
  enableWAL: true,
  enableSnapshots: true,
  maxHistorySize: 100
});

// ç«‹å³ç”Ÿæ•ˆçš„é…ç½®æ›´æ–°
const immediateResult = await configManager.updateConfig({
  volume: 0.8,
  playbackRate: 1.2
}, { immediate: true });

// å»¶è¿Ÿç”Ÿæ•ˆçš„é…ç½®æ›´æ–°
const delayedResult = await configManager.updateConfig({
  loopCount: 3,
  autoPauseEnabled: false,
  gapSkipThreshold: 2000
}, {
  onConflict: 'queue', // é‡åˆ°å†²çªæ—¶è‡ªåŠ¨æ’é˜Ÿ
  timeout: 5000,
  rollbackOnFailure: true
});

// å¤„ç†é…ç½®æ›´æ–°ç»“æœ
if (delayedResult.delayed) {
  console.log(`é…ç½®å°†åœ¨ ${delayedResult.nextUpdateTiming} çŠ¶æ€æ—¶åº”ç”¨`);
}

if (delayedResult.conflicts.length > 0) {
  delayedResult.conflicts.forEach(conflict => {
    switch (conflict.resolution) {
      case 'queue':
        console.log(`é…ç½® ${conflict.key} å·²æ’é˜Ÿç­‰å¾…åº”ç”¨`);
        break;
      case 'confirm':
        showUserConfirmDialog(conflict);
        break;
    }
  });
}

// ç›‘å¬é…ç½®äº‹ä»¶
configManager.on('config:applied', (config, state) => {
  console.log(`é…ç½®å·²åœ¨çŠ¶æ€ ${state} ä¸­æˆåŠŸåº”ç”¨`);
});

configManager.on('config:conflict', (conflict) => {
  if (conflict.metadata?.userActionRequired) {
    handleUserActionRequired(conflict);
  }
});

// é…ç½®å›æ»š
if (needRollback) {
  const rollbackResult = await configManager.rollbackConfig();
  if (rollbackResult.success) {
    console.log(`é…ç½®å·²å›æ»šåˆ°å¿«ç…§ ${rollbackResult.snapshotId}`);
  }
}
````

## 5. æ•°æ®æµè®¾è®¡

### 5.1 æ•°æ®æµæ¶æ„

```
ç”¨æˆ·äº¤äº’ â”€â”€â”
          â”œâ”€â†’ EventHandler â”€â”€â†’ PlayerStateMachine â”€â”€â†’ åŠŸèƒ½æ¨¡å— â”€â”€â†’ PlaybackController â”€â”€â†’ è§†é¢‘å…ƒç´ 
åª’ä½“äº‹ä»¶ â”€â”€â”˜                        â†“
                                çŠ¶æ€å˜æ›´
                                    â†“
                            StateManager â”€â”€â†’ å¤–éƒ¨çŠ¶æ€ (Zustand)
```

### 5.2 æ•°æ®æµåŸåˆ™

1. **å•å‘æ•°æ®æµ**: æ•°æ®åªèƒ½ä»ä¸Šå±‚ç»„ä»¶æµå‘ä¸‹å±‚ç»„ä»¶
2. **äº‹ä»¶é©±åŠ¨**: ç»„ä»¶é—´é€šè¿‡äº‹ä»¶è¿›è¡Œé€šä¿¡
3. **çŠ¶æ€é›†ä¸­**: æ ¸å¿ƒçŠ¶æ€ç”±çŠ¶æ€æœºç»Ÿä¸€ç®¡ç†
4. **å‰¯ä½œç”¨éš”ç¦»**: æ‰€æœ‰å‰¯ä½œç”¨åœ¨æ§åˆ¶å±‚å¤„ç†

### 5.3 çŠ¶æ€åŒæ­¥ç­–ç•¥

```typescript
interface StateManager {
  // çŠ¶æ€åŒæ­¥
  syncToExternal(state: InternalState): void
  syncFromExternal(externalState: ExternalState): void

  // çŠ¶æ€è®¢é˜…
  subscribeToExternal(callback: StateChangeCallback): UnsubscribeFunction

  // çŠ¶æ€éªŒè¯
  validateState(state: any): boolean
  reconcileState(internal: InternalState, external: ExternalState): InternalState
}
```

## 6. æ¥å£å®šä¹‰

### 6.1 é…ç½®æ¥å£

```typescript
interface PlayEngineConfig {
  // æ’­æ”¾è®¾ç½®
  autoPlay: boolean
  playbackRate: number
  volume: number
  muted: boolean

  // å¾ªç¯è®¾ç½®
  loopEnabled: boolean
  loopMode: LoopMode
  loopCount: number

  // è‡ªåŠ¨æ§åˆ¶è®¾ç½®
  autoPauseEnabled: boolean
  pauseOnSubtitleEnd: boolean
  autoResumeEnabled: boolean
  autoResumeDelay: number

  // é—´éš™è·³è·ƒè®¾ç½®
  gapSkipEnabled: boolean
  gapSkipThreshold: number

  // è°ƒè¯•è®¾ç½®
  enableDebugLogs: boolean
  enableStateLogging: boolean

  // æ€§èƒ½è®¾ç½®
  clockThrottleMs: number
  maxStateHistorySize: number

  // é…ç½®çƒ­æ›´æ–°è®¾ç½®
  enableConfigHotUpdate: boolean
  configUpdateSafeStates: PlayerState[]
  maxConfigHistorySize: number
}
```

### 6.2 äº‹ä»¶æ¥å£

```typescript
interface PlayEngineEvents {
  // æ’­æ”¾çŠ¶æ€äº‹ä»¶
  'state:change': (state: PlayerState, previousState: PlayerState) => void
  'playback:play': () => void
  'playback:pause': () => void
  'playback:seek': (time: number) => void
  'playback:ended': () => void

  // å¥å­äº‹ä»¶
  'sentence:change': (sentence: SubtitleItem, index: number) => void
  'sentence:end': (sentence: SubtitleItem, index: number) => void

  // å¾ªç¯äº‹ä»¶
  'loop:start': (count: number) => void
  'loop:end': () => void
  'loop:count-change': (remaining: number) => void

  // è‡ªåŠ¨æ§åˆ¶äº‹ä»¶
  'auto:pause': () => void
  'auto:resume-start': (delay: number) => void
  'auto:resume-cancel': () => void
  'auto:resume-complete': () => void

  // é…ç½®æ›´æ–°äº‹ä»¶
  'config:update-requested': (config: Partial<PlayEngineConfig>, immediate: boolean) => void
  'config:applied': (config: Partial<PlayEngineConfig>, state: PlayerState) => void
  'config:pending': (config: Partial<PlayEngineConfig>, nextTiming: PlayerState) => void
  'config:conflict': (conflict: ConfigConflict) => void
  'config:rollback': (previousConfig: PlayEngineConfig) => void

  // é”™è¯¯äº‹ä»¶
  error: (error: PlayEngineError) => void
}
```

### 6.3 æ•°æ®ç±»å‹å®šä¹‰

```typescript
// å¾ªç¯æ¨¡å¼
enum LoopMode {
  SINGLE = 'single', // å•å¥å¾ªç¯
  PLAYLIST = 'playlist', // åˆ—è¡¨å¾ªç¯ (é¢„ç•™)
  RANDOM = 'random' // éšæœºå¾ªç¯ (é¢„ç•™)
}

// æ’­æ”¾ä¸Šä¸‹æ–‡
interface PlaybackContext {
  // æ’­æ”¾å™¨çŠ¶æ€
  currentTime: number
  duration: number
  playbackRate: number
  volume: number
  muted: boolean

  // å¥å­çŠ¶æ€
  currentSentenceIndex: number
  sentences: SubtitleItem[]

  // å¾ªç¯çŠ¶æ€
  loopEnabled: boolean
  loopMode: LoopMode
  loopCount: number
  loopRemaining: number

  // è‡ªåŠ¨æ§åˆ¶çŠ¶æ€
  autoPauseEnabled: boolean
  autoResumeEnabled: boolean
  autoResumeDelay: number
  gapSkipEnabled: boolean
  gapSkipThreshold: number
}

// å­—å¹•é¡¹
interface SubtitleItem {
  id: string
  startTime: number
  endTime: number
  text: string
  confidence?: number
}

// çŠ¶æ€è½¬æ¢è®°å½•
interface StateTransition {
  from: PlayerState
  to: PlayerState
  event: PlayerEvent
  timestamp: number
  payload?: any
}

// é”™è¯¯ç±»å‹
class PlayEngineError extends Error {
  code: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  context?: any

  constructor(message: string, code: string, severity: PlayEngineError['severity'], context?: any) {
    super(message)
    this.name = 'PlayEngineError'
    this.code = code
    this.severity = severity
    this.context = context
  }
}
```

## 7. é”™è¯¯å¤„ç†

### 7.1 é”™è¯¯åˆ†ç±»

| é”™è¯¯ç±»å‹     | ä¸¥é‡çº§åˆ« | å¤„ç†ç­–ç•¥   |
| ------------ | -------- | ---------- |
| ç½‘ç»œé”™è¯¯     | Medium   | é‡è¯•æœºåˆ¶   |
| è§†é¢‘æ ¼å¼é”™è¯¯ | High     | ç”¨æˆ·æç¤º   |
| å­—å¹•è§£æé”™è¯¯ | Low      | é™é»˜å¤„ç†   |
| çŠ¶æ€æœºé”™è¯¯   | Critical | é‡ç½®çŠ¶æ€æœº |
| å†…å­˜æ³„æ¼     | High     | å¼ºåˆ¶æ¸…ç†   |

### 7.2 é”™è¯¯å¤„ç†æµç¨‹

```typescript
interface ErrorHandler {
  handleError(error: PlayEngineError): void
  registerErrorRecovery(errorCode: string, recovery: ErrorRecoveryFunction): void
  getErrorHistory(): PlayEngineError[]
  clearErrorHistory(): void
}

type ErrorRecoveryFunction = (error: PlayEngineError) => Promise<boolean>
```

### 7.3 é”™è¯¯æ¢å¤ç­–ç•¥

1. **è‡ªåŠ¨é‡è¯•**: ç½‘ç»œç›¸å…³é”™è¯¯è‡ªåŠ¨é‡è¯• 3 æ¬¡
2. **çŠ¶æ€å›æ»š**: çŠ¶æ€æœºé”™è¯¯æ—¶å›æ»šåˆ°æœ€åå·²çŸ¥ç¨³å®šçŠ¶æ€
3. **èµ„æºæ¸…ç†**: å†…å­˜ç›¸å…³é”™è¯¯æ—¶å¼ºåˆ¶æ¸…ç†èµ„æº
4. **ç”¨æˆ·é€šçŸ¥**: ä¸¥é‡é”™è¯¯æ—¶é€šè¿‡äº‹ä»¶é€šçŸ¥ç”¨æˆ·

## 8. æ€§èƒ½è¦æ±‚ä¸å¯è§‚æµ‹æ€§

### 8.1 å¢å¼ºæ€§èƒ½æŒ‡æ ‡ä½“ç³»

#### æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ç±»åˆ«       | æŒ‡æ ‡åç§°           | è¦æ±‚    | P95     | P99      | æµ‹é‡æ–¹æ³•              |
| -------------- | ------------------ | ------- | ------- | -------- | --------------------- |
| **å“åº”æ€§**     | çŠ¶æ€è½¬æ¢å»¶è¿Ÿ       | < 5ms   | < 8ms   | < 15ms   | OpenTelemetry Trace   |
|                | äº‹ä»¶å¤„ç†å»¶è¿Ÿ       | < 10ms  | < 15ms  | < 25ms   | Performance Timeline  |
|                | å¥å­æŸ¥æ‰¾æ—¶é—´       | < 1ms   | < 2ms   | < 5ms    | è‡ªå®šä¹‰æŒ‡æ ‡            |
| **ç«¯åˆ°ç«¯å»¶è¿Ÿ** | ç”¨æˆ·æ“ä½œåˆ°åª’ä½“å“åº” | < 100ms | < 150ms | < 300ms  | User Timing API       |
|                | é…ç½®æ›´æ–°åˆ°ç”Ÿæ•ˆ     | < 50ms  | < 100ms | < 200ms  | Config Timeline       |
|                | Seekæ“ä½œåˆ°ç¨³å®š     | < 200ms | < 500ms | < 1000ms | Media Event Tracking  |
| **èµ„æºä½¿ç”¨**   | å†…å­˜ä½¿ç”¨           | < 50MB  | < 80MB  | < 100MB  | Memory API            |
|                | CPUä½¿ç”¨ç‡          | < 30%   | < 50%   | < 70%    | Performance Observer  |
|                | çŠ¶æ€æœºå¯åŠ¨æ—¶é—´     | < 100ms | < 200ms | < 500ms  | Startup Tracing       |
| **å‡†ç¡®æ€§**     | Seekå‘½ä¸­ç‡         | > 95%   | > 90%   | > 85%    | Seek Accuracy Metrics |
|                | å¾ªç¯ç²¾ç¡®åº¦         | > 99%   | > 98%   | > 95%    | Loop Timing Analysis  |
|                | è¾¹ç•Œæ£€æµ‹ç²¾åº¦       | > 95%   | > 90%   | > 85%    | Boundary Detection    |

#### æ‰©å±•æ€§èƒ½æŒ‡æ ‡

| åœºæ™¯           | æŒ‡æ ‡              | è¦æ±‚        | æµ‹è¯•æ–¹æ³•              |
| -------------- | ----------------- | ----------- | --------------------- |
| **å¤§å®¹é‡å­—å¹•** | 10k+ å¥å­æŸ¥è¯¢æ€§èƒ½ | < 5ms       | Stress Testing        |
| **é«˜é¢‘äº‹ä»¶**   | 100 äº‹ä»¶/ç§’å¤„ç†   | < 50ms å»¶è¿Ÿ | Event Burst Testing   |
| **å¹¶å‘æ“ä½œ**   | 10 å¹¶å‘é…ç½®æ›´æ–°   | < 100ms     | Concurrency Testing   |
| **é•¿æ—¶é—´è¿è¡Œ** | 24å°æ—¶è¿ç»­è¿è¡Œ    | å†…å­˜æ— æ³„æ¼  | Memory Leak Detection |

### 8.2 OpenTelemetry é›†æˆ

#### è¿½è¸ªæ¶æ„

```typescript
import { trace, metrics, logs } from '@opentelemetry/api'
import { Resource } from '@opentelemetry/resources'
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'

// OpenTelemetry åˆå§‹åŒ–
const resource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: 'echoplayer-engine-v3',
  [SemanticResourceAttributes.SERVICE_VERSION]: '3.0.0',
  [SemanticResourceAttributes.SERVICE_NAMESPACE]: 'echoplayer'
})

// Tracer åˆå§‹åŒ–
const tracer = trace.getTracer('player-engine', '3.0.0')
const meter = metrics.getMeter('player-engine', '3.0.0')

// æ ¸å¿ƒæŒ‡æ ‡å®šä¹‰
const stateTransitionDuration = meter.createHistogram('state_transition_duration_ms', {
  description: 'çŠ¶æ€è½¬æ¢æ‰§è¡Œæ—¶é—´',
  unit: 'ms',
  boundaries: [1, 2, 5, 10, 20, 50, 100, 200, 500]
})

const eventProcessingDuration = meter.createHistogram('event_processing_duration_ms', {
  description: 'äº‹ä»¶å¤„ç†æ‰§è¡Œæ—¶é—´',
  unit: 'ms'
})

const activeStatesGauge = meter.createUpDownCounter('active_states_count', {
  description: 'å½“å‰æ´»è·ƒçŠ¶æ€æ•°é‡'
})

const memoryUsageGauge = meter.createObservableGauge('memory_usage_bytes', {
  description: 'å†…å­˜ä½¿ç”¨é‡',
  unit: 'bytes'
})

// æ ¸å¿ƒç»„ä»¶å™¨è£…
class TelemetryInstrumentation {
  // çŠ¶æ€æœºå™¨è£…
  instrumentStateMachine(stateMachine: PlayerStateMachine): void {
    const originalSend = stateMachine.send.bind(stateMachine)

    stateMachine.send = (event: PlayerEvent) => {
      const span = tracer.startSpan('state_machine.send', {
        attributes: {
          'event.type': event.type,
          'state.current': JSON.stringify(stateMachine.getCurrentState())
        }
      })

      const startTime = performance.now()

      try {
        const result = originalSend(event)

        const duration = performance.now() - startTime
        stateTransitionDuration.record(duration, {
          event_type: event.type,
          success: 'true'
        })

        span.setAttributes({
          'state.new': JSON.stringify(result.value),
          'transition.duration_ms': duration,
          'transition.success': true
        })

        span.setStatus({ code: trace.SpanStatusCode.OK })
        return result
      } catch (error) {
        const duration = performance.now() - startTime
        stateTransitionDuration.record(duration, {
          event_type: event.type,
          success: 'false',
          error_type: error.constructor.name
        })

        span.recordException(error as Error)
        span.setStatus({
          code: trace.SpanStatusCode.ERROR,
          message: (error as Error).message
        })
        throw error
      } finally {
        span.end()
      }
    }
  }

  // é…ç½®ç®¡ç†å™¨è£…
  instrumentConfigManager(configManager: ConfigManager): void {
    const originalUpdateConfig = configManager.updateConfig.bind(configManager)

    configManager.updateConfig = async (
      patch: Partial<PlayEngineConfig>,
      options?: ConfigUpdateOptions
    ) => {
      return tracer.startActiveSpan(
        'config_manager.update_config',
        {
          attributes: {
            'config.keys': Object.keys(patch).join(','),
            'config.immediate': options?.immediate || false,
            'config.timeout': options?.timeout || 0
          }
        },
        async (span) => {
          try {
            const result = await originalUpdateConfig(patch, options)

            span.setAttributes({
              'config.applied': result.applied,
              'config.delayed': result.delayed,
              'config.conflicts_count': result.conflicts?.length || 0
            })

            return result
          } catch (error) {
            span.recordException(error as Error)
            span.setStatus({
              code: trace.SpanStatusCode.ERROR,
              message: (error as Error).message
            })
            throw error
          } finally {
            span.end()
          }
        }
      )
    }
  }

  // PlaybackController å™¨è£…
  instrumentPlaybackController(controller: PlaybackController): void {
    const operations = ['play', 'pause', 'seek'] as const

    operations.forEach((op) => {
      const originalMethod = (controller as any)[op].bind(controller)

      ;(controller as any)[op] = async (...args: any[]) => {
        return tracer.startActiveSpan(
          `playback_controller.${op}`,
          {
            attributes: {
              operation: op,
              args: JSON.stringify(args)
            }
          },
          async (span) => {
            const startTime = performance.now()

            try {
              const result = await originalMethod(...args)
              const duration = performance.now() - startTime

              span.setAttributes({
                duration_ms: duration,
                success: result?.success || true
              })

              return result
            } catch (error) {
              span.recordException(error as Error)
              throw error
            } finally {
              span.end()
            }
          }
        )
      }
    })
  }
}
```

#### è‡ªå®šä¹‰æŒ‡æ ‡å’Œçœ‹æ¿

```typescript
// ä¸šåŠ¡æŒ‡æ ‡å®šä¹‰
interface BusinessMetrics {
  // ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
  userEngagement: {
    sessionDuration: number
    interactionCount: number
    featureUsage: Record<string, number>
  }

  // æ’­æ”¾è´¨é‡æŒ‡æ ‡
  playbackQuality: {
    seekAccuracy: number
    loopPrecision: number
    bufferHealthScore: number
    errorRate: number
  }

  // æ€§èƒ½æ•ˆç‡æŒ‡æ ‡
  performance: {
    stateTransitionP95: number
    memoryEfficiency: number
    cpuUtilization: number
    batteryImpact: number
  }
}

// å®æ—¶æŒ‡æ ‡çœ‹æ¿
class MetricsDashboard {
  private metrics: Map<string, MetricValue> = new Map()
  private alerts: Alert[] = []

  updateMetric(name: string, value: number, labels?: Record<string, string>): void {
    const metric = {
      value,
      timestamp: Date.now(),
      labels: labels || {}
    }

    this.metrics.set(name, metric)
    this.checkThresholds(name, value)
    this.emitMetric(name, metric)
  }

  private checkThresholds(name: string, value: number): void {
    const threshold = this.getThreshold(name)
    if (threshold && value > threshold.warning) {
      this.createAlert({
        metric: name,
        value,
        threshold: threshold.warning,
        severity: value > threshold.critical ? 'critical' : 'warning',
        timestamp: Date.now()
      })
    }
  }

  getHealthScore(): HealthScore {
    const metrics = Array.from(this.metrics.values())
    const recentAlerts = this.alerts.filter(
      (a) => Date.now() - a.timestamp < 300000 // 5åˆ†é’Ÿå†…
    )

    return {
      overall: this.calculateOverallHealth(metrics, recentAlerts),
      components: {
        performance: this.calculateComponentHealth('performance', metrics),
        reliability: this.calculateComponentHealth('reliability', metrics),
        resources: this.calculateComponentHealth('resources', metrics)
      },
      alerts: recentAlerts,
      recommendations: this.generateRecommendations(metrics, recentAlerts)
    }
  }
}
```

### 8.3 å¼‚å¸¸æ£€æµ‹å’Œé¢„è­¦

#### æ™ºèƒ½é¢„è­¦ç³»ç»Ÿ

```typescript
interface AlertingSystem {
  // é˜ˆå€¼ç®¡ç†
  thresholds: {
    stateTransitionLatency: { warning: 10; critical: 25 } // ms
    memoryUsage: { warning: 80; critical: 100 } // MB
    errorRate: { warning: 0.01; critical: 0.05 } // percentage
    seekAccuracy: { warning: 0.9; critical: 0.8 } // accuracy rate
  }

  // å¼‚å¸¸æ¨¡å¼æ£€æµ‹
  anomalyDetection: {
    baseline: MetricsBaseline
    algorithm: 'statistical' | 'ml' | 'rule_based'
    sensitivity: number
  }

  // é¢„æµ‹æ€§é¢„è­¦
  predictiveAlerts: {
    memoryLeakPrediction: boolean
    performanceDegradation: boolean
    resourceExhaustion: boolean
  }
}

// æ•…éšœæ³¨å…¥å’Œæ··æ²Œå·¥ç¨‹
class ChaosEngineering {
  // æ•…éšœæ³¨å…¥åœºæ™¯
  injectFailures(): void {
    // éšæœºä¸¢å¸§
    this.injectRandomFrameDrops()

    // Seek å»¶è¿Ÿ
    this.injectSeekLatency()

    // çŠ¶æ€è½¬æ¢å»¶è¿Ÿ
    this.injectStateTransitionDelay()

    // å†…å­˜å‹åŠ›
    this.injectMemoryPressure()

    // ç½‘ç»œæŠ–åŠ¨
    this.injectNetworkJitter()
  }

  // æ€§èƒ½åŸºå‡†æµ‹è¯•
  runPerformanceBenchmarks(): BenchmarkResult {
    return {
      stateTransitions: this.benchmarkStateTransitions(),
      eventProcessing: this.benchmarkEventProcessing(),
      memoryUsage: this.benchmarkMemoryUsage(),
      seekAccuracy: this.benchmarkSeekAccuracy(),
      batteryImpact: this.benchmarkBatteryImpact()
    }
  }
}
```

### 8.4 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

## 9. æµ‹è¯•ç­–ç•¥

### 9.1 æµ‹è¯•å±‚çº§

1. **å•å…ƒæµ‹è¯•**: æµ‹è¯•å•ä¸ªç»„ä»¶çš„åŠŸèƒ½
2. **é›†æˆæµ‹è¯•**: æµ‹è¯•ç»„ä»¶é—´çš„åä½œ
3. **ç«¯åˆ°ç«¯æµ‹è¯•**: æµ‹è¯•å®Œæ•´çš„æ’­æ”¾æµç¨‹
4. **æ€§èƒ½æµ‹è¯•**: æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
5. **å‹åŠ›æµ‹è¯•**: æµ‹è¯•æé™æƒ…å†µ

### 9.2 æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

| ç»„ä»¶       | è¦†ç›–ç‡è¦æ±‚ |
| ---------- | ---------- |
| æ ¸å¿ƒçŠ¶æ€æœº | 95%        |
| åŠŸèƒ½æ¨¡å—   | 90%        |
| æ§åˆ¶å±‚     | 85%        |
| å·¥å…·å‡½æ•°   | 95%        |

### 9.3 æµ‹è¯•å·¥å…·

- **å•å…ƒæµ‹è¯•**: Vitest + Testing Library
- **çŠ¶æ€æœºæµ‹è¯•**: @xstate/test
- **ç«¯åˆ°ç«¯æµ‹è¯•**: Playwright
- **æ€§èƒ½æµ‹è¯•**: è‡ªå®šä¹‰æ€§èƒ½å¥—ä»¶

### 9.4 æµ‹è¯•ç”¨ä¾‹è®¾è®¡

```typescript
// çŠ¶æ€æœºæµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹
describe('PlayerStateMachine', () => {
  describe('å¾ªç¯æ’­æ”¾æµç¨‹', () => {
    it('åº”è¯¥åœ¨å¥å­ç»“æŸåæ£€æŸ¥å¾ªç¯è®¾ç½®', async () => {
      // Given: å¯ç”¨å•å¥å¾ªç¯
      // When: å¥å­æ’­æ”¾ç»“æŸ
      // Then: åº”è¯¥è½¬æ¢åˆ° CHECK_LOOP çŠ¶æ€
    })

    it('åº”è¯¥åœ¨å¾ªç¯æ¬¡æ•°ä¸º0æ—¶åœæ­¢å¾ªç¯', async () => {
      // Given: å¾ªç¯æ¬¡æ•°ä¸º1çš„å¾ªç¯æ’­æ”¾
      // When: å¾ªç¯æ‰§è¡Œä¸€æ¬¡å
      // Then: åº”è¯¥åœæ­¢å¾ªç¯å¹¶ç»§ç»­æ’­æ”¾ä¸‹ä¸€å¥
    })
  })
})
```

## 10. è¿ç§»è®¡åˆ’

### 10.1 è¿ç§»é˜¶æ®µ

**é˜¶æ®µä¸€: åŸºç¡€æ¶æ„å¤ç”¨ (Week 1)**

- âœ… **ç›´æ¥å¤ç”¨**: `TimeMath`ã€`MediaClock`ã€`ClockScheduler` (95%ä»£ç å¯ç”¨)
- âœ… **æ¥å£é€‚é…**: `VideoController`ã€`StateUpdater` å¢å¼ºä¸º `PlaybackController`
- ğŸ”§ **é‡æ„å¤ç”¨**: `SubtitleIndexCalculator` â†’ `SentenceManager` æ ¸å¿ƒç®—æ³•

**é˜¶æ®µäºŒ: çŠ¶æ€æœºå®ç° (Week 2)**

- ğŸ†• **æ–°å»º**: åŸºäº XState çš„ `PlayerStateMachine`
- ğŸ”§ **å‚è€ƒé‡å†™**: ä» `PlayerOrchestrator` æå–äº‹ä»¶å¤„ç†é€»è¾‘
- âœ… **å¤ç”¨**: `SubtitleLockFSM` æ¦‚å¿µç”¨äºçŠ¶æ€åè°ƒ

**é˜¶æ®µä¸‰: åŠŸèƒ½æ¨¡å—è¿ç§» (Week 3)**

- âœ… **ç®—æ³•å¤ç”¨**: V2 ç­–ç•¥çš„æ ¸å¿ƒé€»è¾‘ â†’ V3 åŠŸèƒ½æ¨¡å—
- ğŸ”§ **æ¶æ„ç®€åŒ–**: å»é™¤å¤æ‚çš„æ„å›¾ç³»ç»Ÿï¼Œé‡‡ç”¨ç›´æ¥çš„çŠ¶æ€é©±åŠ¨
- âœ… **æµ‹è¯•å¤ç”¨**: V2 çš„æµ‹è¯•ç”¨ä¾‹å’Œè¾¹ç•Œæ¡ä»¶æ£€æµ‹

**é˜¶æ®µå››: é›†æˆä¸ä¼˜åŒ– (Week 4)**

- æ€§èƒ½å¯¹æ¯”éªŒè¯ (ç›®æ ‡: ä¸åŠ£äºV2)
- å…¼å®¹æ€§æµ‹è¯•
- ç”Ÿäº§éƒ¨ç½²

### 10.2 å…¼å®¹æ€§ç­–ç•¥

1. **ä¿æŒæ¥å£å…¼å®¹**: æ–°å¼•æ“å®ç°ç°æœ‰çš„å…¬å…±æ¥å£
2. **æ¸è¿›å¼æ›¿æ¢**: ä½¿ç”¨é€‚é…å™¨æ¨¡å¼é€æ­¥æ›¿æ¢ç»„ä»¶
3. **ç‰¹æ€§å¼€å…³**: ä½¿ç”¨é…ç½®å¼€å…³æ§åˆ¶æ–°æ—§å¼•æ“çš„ä½¿ç”¨
4. **å›æ»šæœºåˆ¶**: å‡ºç°é—®é¢˜æ—¶èƒ½å¿«é€Ÿå›æ»šåˆ°æ—§ç‰ˆæœ¬

### 10.3 é£é™©æ§åˆ¶

| é£é™©       | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½                 |
| ---------- | ---- | ---- | ------------------------ |
| æ€§èƒ½å›é€€   | ä¸­   | é«˜   | è¯¦ç»†çš„æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†å¯¹æ¯” |
| åŠŸèƒ½ä¸¢å¤±   | ä½   | é«˜   | å®Œæ•´çš„åŠŸèƒ½æ˜ å°„å’Œæµ‹è¯•     |
| ç¨³å®šæ€§é—®é¢˜ | ä¸­   | ä¸­   | å……åˆ†çš„é›†æˆæµ‹è¯•å’Œç°åº¦å‘å¸ƒ |
| è¿ç§»å»¶æœŸ   | é«˜   | ä¸­   | åˆ†é˜¶æ®µè¿ç§»ï¼Œä¼˜å…ˆçº§æ’åº   |

### 10.4 æˆåŠŸæ ‡å‡†

1. **åŠŸèƒ½å®Œæ•´æ€§**: 100% åŠŸèƒ½ç‰¹æ€§è¦†ç›–
2. **æ€§èƒ½æŒ‡æ ‡**: ä¸åŠ£äºç°æœ‰ç‰ˆæœ¬
3. **ç¨³å®šæ€§**: é”™è¯¯ç‡ < 0.1%
4. **å¼€å‘ä½“éªŒ**: æ–°å¢åŠŸèƒ½å¼€å‘æ•ˆç‡æå‡ 50%
5. **ç»´æŠ¤æˆæœ¬**: ä»£ç å¤æ‚åº¦é™ä½ 30%

---

## é™„å½•

### A. V2 åˆ° V3 ç»„ä»¶æ˜ å°„è¡¨

| V2 ç»„ä»¶                   | V3 ç»„ä»¶                | å¤ç”¨åº¦ | è¿ç§»ç­–ç•¥                       |
| ------------------------- | ---------------------- | ------ | ------------------------------ |
| `TimeMath`                | `TimeMath`             | 95%    | ç›´æ¥å¤ç”¨ï¼Œå·²å®Œç¾ç¬¦åˆV3éœ€æ±‚     |
| `MediaClock`              | `MediaClock`           | 85%    | ç›´æ¥å¤ç”¨ï¼Œå…·å¤‡æ‰€æœ‰V3è¦æ±‚çš„ç‰¹æ€§ |
| `ClockScheduler`          | è°ƒåº¦åŠŸèƒ½               | 90%    | ç›´æ¥å¤ç”¨ï¼Œé›†æˆåˆ°åŸºç¡€è®¾æ–½å±‚     |
| `SubtitleIndexCalculator` | `SentenceManager` æ ¸å¿ƒ | 80%    | ç®—æ³•å¤ç”¨ï¼Œæ¥å£é‡æ–°è®¾è®¡         |
| `VideoController`         | `PlaybackController`   | 70%    | æ¥å£æ‰©å±•ï¼Œå¢åŠ è¿æ¥ç®¡ç†         |
| `StateUpdater`            | çŠ¶æ€åŒæ­¥æ¥å£           | 70%    | æ¥å£é€‚é…ï¼Œä¿æŒå…¼å®¹æ€§           |
| `SubtitleLockFSM`         | çŠ¶æ€åè°ƒæœºåˆ¶           | 60%    | æ¦‚å¿µå¤ç”¨ï¼Œç®€åŒ–å®ç°             |
| `PlayerOrchestrator`      | `PlayEngine`           | 30%    | å‚è€ƒäº‹ä»¶å¤„ç†ï¼Œç®€åŒ–æ¶æ„         |
| `Intent/Strategy` ç³»ç»Ÿ    | åŠŸèƒ½æ¨¡å—               | 20%    | æå–æ ¸å¿ƒé€»è¾‘ï¼Œå»é™¤å¤æ‚æŠ½è±¡     |

### B. è¯æ±‡è¡¨

| æœ¯è¯­     | å®šä¹‰                                 |
| -------- | ------------------------------------ |
| çŠ¶æ€æœº   | æœ‰é™çŠ¶æ€æœºï¼Œç”¨äºç®¡ç†æ’­æ”¾å™¨çš„çŠ¶æ€è½¬æ¢ |
| å¥å­     | å­—å¹•ä¸­çš„ä¸€ä¸ªå®Œæ•´è¯­å¥å•å…ƒ             |
| å¾ªç¯     | é‡å¤æ’­æ”¾å½“å‰å¥å­çš„åŠŸèƒ½               |
| é—´éš™è·³è·ƒ | è‡ªåŠ¨è·³è¿‡å­—å¹•é—´çš„ç©ºç™½æ—¶é—´             |
| è‡ªåŠ¨æš‚åœ | åœ¨å¥å­ç»“æŸåè‡ªåŠ¨æš‚åœæ’­æ”¾             |
| è‡ªåŠ¨æ¢å¤ | åœ¨æš‚åœåè‡ªåŠ¨æ¢å¤æ’­æ”¾                 |

### C. å‚è€ƒèµ„æ–™

- [XState å®˜æ–¹æ–‡æ¡£](https://xstate.js.org/)
- [TypeScript ç¼–ç è§„èŒƒ](https://typescript-eslang.io/)
- [React æ€§èƒ½æœ€ä½³å®è·µ](https://react.dev/learn/render-and-commit)
- [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
- [V2 å¼•æ“æºç ](./): å¯å¤ç”¨ç»„ä»¶çš„å…·ä½“å®ç°å‚è€ƒ

---

> **æ³¨æ„**: æœ¬è§„èŒƒæ˜¯ä¸€ä¸ªæ´»è·ƒæ–‡æ¡£ï¼Œéšç€å¼€å‘è¿›å±•ä¼šæŒç»­æ›´æ–°ã€‚æ‰€æœ‰å˜æ›´éƒ½åº”è¯¥é€šè¿‡ PR å®¡æŸ¥æµç¨‹ã€‚é…ç½®çƒ­æ›´æ–°åŠŸèƒ½æ˜¯ V3 å¼•æ“çš„é‡è¦ç‰¹æ€§ï¼Œç¡®ä¿äº†ç”¨æˆ·é…ç½®æ›´æ”¹çš„å³æ—¶å“åº”å’Œæ’­æ”¾ä½“éªŒçš„è¿ç»­æ€§ã€‚
